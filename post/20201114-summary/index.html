<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2020.11.14考试总结 | Lcy&#39;s Blog</title>
<link rel="shortcut icon" href="https://lcy09.github.io/favicon.ico?v=1606707336451">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lcy09.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="2020.11.14考试总结 | Lcy&#39;s Blog - Atom Feed" href="https://lcy09.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="1.演讲
题目描述
大洋彼岸的没事干国有nnn个人（编号为 111 到 nnn ）闲着没事要竞选总统。
为了显示其他候选人的无法胜任，这些人需要上台演讲。
第一天 111 号候选人开始发言，把222号狠狠地D了一通。
如果某天jjj号候选人..." />
    <meta name="keywords" content="枚举，暴力,最小生成树,Trie树,倍增，ST表,考试总结,构造" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lcy09.github.io">
  <img class="avatar" src="https://lcy09.github.io/images/avatar.png?v=1606707336451" alt="">
  </a>
  <h1 class="site-title">
    Lcy&#39;s Blog
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              2020.11.14考试总结
            </h2>
            <div class="post-info">
              <span>
                2020-11-15
              </span>
              <span>
                20 min read
              </span>
              
                <a href="https://lcy09.github.io/tag/cYiU-ugMw/" class="post-tag">
                  # 枚举，暴力
                </a>
              
                <a href="https://lcy09.github.io/tag/2-vfG50d7Q/" class="post-tag">
                  # 最小生成树
                </a>
              
                <a href="https://lcy09.github.io/tag/BfzEJyUYva/" class="post-tag">
                  # Trie树
                </a>
              
                <a href="https://lcy09.github.io/tag/wz1Mu__x9o/" class="post-tag">
                  # 倍增，ST表
                </a>
              
                <a href="https://lcy09.github.io/tag/5NgFH_-G65/" class="post-tag">
                  # 考试总结
                </a>
              
                <a href="https://lcy09.github.io/tag/_YUJo5rDxv/" class="post-tag">
                  # 构造
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://lcy09.github.io/post-images/20201114-summary.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="1演讲">1.演讲</h3>
<p><strong>题目描述</strong></p>
<p>大洋彼岸的没事干国有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个人（编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ）闲着没事要竞选总统。</p>
<p>为了显示其他候选人的无法胜任，这些人需要上台演讲。</p>
<p>第一天 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号候选人开始发言，把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>号狠狠地D了一通。</p>
<p>如果某天<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>号候选人 D 了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 号，那么下一天就由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>号候选人发言，且这一天他要 D 的人是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 号。</p>
<p>没事干国的人都很无聊，所以演讲将无穷无尽地持续下去。那么第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>天发言的会是几号呢？</p>
<p><strong>输入格式</strong></p>
<p>第一行一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">n,d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span>——有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个候选人，询问第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 天发言的候选人。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，其中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>输出格式</strong></p>
<p>一行一个数表示答案。</p>
<p><strong>数据规模与约定</strong></p>
<p>对于所有数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>600</mn><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><mi>d</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">2≤n≤600，1≤d≤10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>；</p>
<p>保证不存在自己 D 自己的情况，输入中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g_{i,i}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">≠</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">i\ne j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1≤g_{i,j}≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.922078em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p>发现相邻两个元素构成的二元组最多只可能有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个，所以暴力map来找循环节即可。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=605;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,d;
int g[MAXN][MAXN];

int ord[MAXN*MAXN*2],len,pos;
map&lt;int,int&gt;mp;

signed main()
{
    n=read(),d=read();
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            g[i][j]=read();
    
    ord[++len]=1,ord[++len]=2,mp[1002]=1;
    for(int i=3;i&lt;=n*n;i++)
    {
        ord[len=i]=g[ord[i-1]][ord[i-2]];
        int tmp=ord[i-1]*1000+ord[i];
        if(mp[tmp]) 
        {
            len-=2,pos=mp[tmp];
            break;
        }
        else mp[tmp]=i-1;
    }

    if(d&lt;=len) printf(&quot;%lld\n&quot;,ord[d]);
    else
    {
        d-=(pos-1);
        d%=(len-pos+1);
        if(!d) printf(&quot;%lld\n&quot;,ord[len]);
        else printf(&quot;%lld\n&quot;,ord[d+pos-1]);
    }
    
    return 0;
}
</code></pre>
<h3 id="2卡车调度">2.卡车调度</h3>
<p><a href="http://www.sjzezoj.com:9280/problem/50">题面</a></p>
<p><strong>solution</strong></p>
<p>77分纪念版写法</p>
<p>建立最小生成树进行树剖，然后记录每个点连接的轻边边权最小值和非树边最小值。每次查询是分成很多段的，先标记路径并计算链上的边的答案，每段的首尾端点暴力更新答案，中间查询轻边和非树边进行更新即可。</p>
<p>（这屑做法写了7.3k我居然考场上yy出来了……）</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define ls num&lt;&lt;1
#define rs num&lt;&lt;1|1
using namespace std;
const int MAXN=300005;
const int MAXM=1000005;
const int inf=0x3f3f3f3f3f3f3f3f;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline void Min(int &amp;x,int y) {if(y&lt;x) x=y;}
inline void Max(int &amp;x,int y) {if(y&gt;x) x=y;}

int n,m,q;
struct ED
{
    int ep1,ep2;
    int val;
    bool ontr;//是否在树上
}e[MAXM];
bool cmp(ED a,ED b) {return a.val&lt;b.val;}

int head[MAXN];
struct EDGE
{
    int from,to;
    int val;
    int next;
}edge[MAXM&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to,int val)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].val=val;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}

int fat[MAXN];
int find(int x)
{
    if(x==fat[x]) return x;
    return fat[x]=find(fat[x]);
}
void Kruskal()
{
    for(int i=1;i&lt;=n;i++) fat[i]=i;
    sort(e+1,e+m+1,cmp);
    int ecnt=0;
    for(int i=1;i&lt;=m;i++)
    {
        int u=find(e[i].ep1),v=find(e[i].ep2);
        if(u==v) continue;
        fat[u]=v;
        add_edge(e[i].ep1,e[i].ep2,e[i].val);
        add_edge(e[i].ep2,e[i].ep1,e[i].val);
        ecnt++,e[i].ontr=1;
        if(ecnt==n-1) break;
    }
}

int dfs_cnt;
int fa[MAXN],son[MAXN];
int dfn[MAXN],rev[MAXN],depth[MAXN];
int siz[MAXN],top[MAXN],bot[MAXN];
int ev[MAXN],Mle[MAXN],nontr[MAXN];
//代表每个点的返祖边,每个点的轻边,每个点的非树边
//直接路径上查最大,烂树杈子查最小
inline void dfs_son(int x,int fath)
{
    depth[x]=depth[fa[x]=fath]+(siz[x]=1);
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(y==fath) continue;
        ev[y]=edge[i].val;
        dfs_son(y,x);
        siz[x]+=siz[y];
        if(siz[y]&gt;siz[son[x]]) son[x]=y;
    }
}
inline void dfs_chain(int x,int tp)
{
    rev[dfn[x]=++dfs_cnt]=x;
    top[x]=tp;
    if(son[x]) dfs_chain(son[x],tp),bot[x]=bot[son[x]];
    else bot[x]=x;//递归记录链底
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(dfn[y]) continue;
        dfs_chain(y,y);
    }
}
struct SegmentTree
{
    int left,right;
    int mk,EV,Mle,nontr;
    int willbe;
}tree[MAXN&lt;&lt;2];
inline void pushup(int num)
{
    tree[num].EV=max(tree[ls].EV,tree[rs].EV);
    tree[num].Mle=min(tree[ls].Mle,tree[rs].Mle);
    tree[num].nontr=min(tree[ls].nontr,tree[rs].nontr);
}
inline void build(int num,int l,int r)
{
    tree[num].left=l,tree[num].right=r;
    tree[num].willbe=inf;
    if(l==r)
    {
        tree[num].EV=ev[rev[l]];
        tree[num].Mle=Mle[rev[l]];
        tree[num].nontr=nontr[rev[l]];
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    build(ls,l,mid),build(rs,mid+1,r);
    pushup(num);
}
inline void pushdown(int num)
{
    if(tree[num].willbe&gt;1e10) return ;
    int wb=tree[num].willbe;
    tree[ls].willbe=tree[rs].willbe=wb;
    tree[ls].mk=tree[rs].mk=wb;
    tree[num].willbe=inf;
}
inline void change(int num,int l,int r,int wb)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
    {
        tree[num].mk=tree[num].willbe=wb;
        return ;
    }
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) change(ls,l,r,wb);
    else if(l&gt;mid) change(rs,l,r,wb);
    else
        change(ls,l,mid,wb),change(rs,mid+1,r,wb);
    tree[num].mk=tree[ls].mk|tree[rs].mk;
}
inline int querymk(int num,int pos)
{
    if(tree[num].left==tree[num].right)
        return tree[num].mk;
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(pos&lt;=mid) return querymk(ls,pos);
    else return querymk(rs,pos);
}
inline int queryev(int num,int l,int r)
{
    if(l&gt;r) return 0;
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].EV;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return queryev(ls,l,r);
    else if(l&gt;mid) return queryev(rs,l,r);
    else return max(queryev(ls,l,mid),queryev(rs,mid+1,r));
}
inline int querymle(int num,int l,int r)
{
    if(l&gt;r) return inf;
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].Mle;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return querymle(ls,l,r);
    else if(l&gt;mid) return querymle(rs,l,r);
    else return min(querymle(ls,l,mid),querymle(rs,mid+1,r));
}
inline int querynt(int num,int l,int r)
{
    if(l&gt;r) return inf;
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].nontr;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return querynt(ls,l,r);
    else if(l&gt;mid) return querynt(rs,l,r);
    else return min(querynt(ls,l,mid),querynt(rs,mid+1,r));
}

inline void update(int x,int y,int wb)
{
    while(top[x]!=top[y])
    {
        if(depth[top[x]]&lt;depth[top[y]]) swap(x,y);
        change(1,dfn[top[x]],dfn[x],wb);
        x=fa[top[x]];
    }
    if(depth[x]&gt;depth[y]) swap(x,y);
    change(1,dfn[x],dfn[y],wb);
}
inline int get_m(int x)
{
    int res=nontr[x];
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(querymk(1,dfn[y])) continue;
        Min(res,edge[i].val);
    }
    return res;
}
inline int ask(int x,int y)
{
    update(x,y,1);
    int tx=x,ty=y,res1=0,res2=inf;
    while(top[tx]!=top[ty])
    {
        if(depth[top[tx]]&lt;depth[top[ty]]) swap(tx,ty);
        Max(res1,queryev(1,dfn[top[tx]],dfn[tx]));
        tx=fa[top[tx]];
    }
    if(depth[tx]&gt;depth[ty]) swap(tx,ty);
    Max(res1,queryev(1,dfn[tx]+1,dfn[ty]));

    tx=x,ty=y;
    while(top[tx]!=top[ty])
    {
        if(depth[top[tx]]&lt;depth[top[ty]]) swap(tx,ty);
        Min(res2,querymle(1,dfn[top[tx]]+1,dfn[tx]-1));
        Min(res2,querynt(1,dfn[top[tx]]+1,dfn[tx]-1));
        Min(res2,get_m(top[tx])),Min(res2,get_m(tx));
        tx=fa[top[tx]];
    }
    if(depth[tx]&gt;depth[ty]) swap(tx,ty);
    Min(res2,querymle(1,dfn[tx]+1,dfn[ty]-1));
    Min(res2,querynt(1,dfn[tx]+1,dfn[ty]-1));
    Min(res2,get_m(tx)),Min(res2,get_m(ty));

    update(x,y,0);
    if(res2&gt;1e10) return -1;
    return max(res1,res2);
}

signed main()
{
    n=read(),m=read(),q=read();
    for(int i=1;i&lt;=m;i++)
        e[i].ep1=read(),e[i].ep2=read(),e[i].val=read();

    Kruskal();
    dfs_son(1,0),dfs_chain(1,1);
    memset(Mle,0x3f,sizeof(Mle));
    memset(nontr,0x3f,sizeof(nontr));
    for(int i=1;i&lt;=m;i++)
    {
        if(e[i].ontr) continue;
        Min(nontr[e[i].ep1],e[i].val);
        Min(nontr[e[i].ep2],e[i].val);
    }
    for(int x=1;x&lt;=n;x++)
    {
        if(top[x]!=x) continue;
        for(int i=head[x];i;i=edge[i].next)
        {
            int y=edge[i].to;
            if(y!=fa[x]) continue;
            Min(Mle[x],edge[i].val),Min(Mle[y],edge[i].val);
            break;
        }
    }
    build(1,1,n);

    while(q--)
    {
        int x=read(),y=read();
        write(ask(x,y));
    }

    return 0;
}
</code></pre>
<p>正解</p>
<p>首先考虑二分答案,发现两个点之间的简单路径一定在整张图的最小生成树上或者可以转化到最小生成树上，所以先建立出整张图的最小生成树。</p>
<p>在根据边权对边排序后，越早加入的边越优，发现在一条链上，点的度数只有1和2两种，所以只需要记录下每个点的度数大于1和2瞬间的加入边权，然后存在倍增数组里，每次询问就像找LCA一样倍增向上跳，边跳边更新答案，即用链的两个端点的第二条加入边和链上其它点的第三条加入边来更新那个伸出去的道路的答案。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=300005;
const int MAXM=1000005;
const int inf=0x3f3f3f3f3f3f3f3f;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline void Min(int &amp;x,int y) {if(y&lt;x) x=y;}
inline void Max(int &amp;x,int y) {if(y&gt;x) x=y;}

int n,m,q;

struct ED
{
    int ep1,ep2;
    int val;
}e[MAXM];
bool cmp(ED a,ED b) {return a.val&lt;b.val;}
int fat[MAXN];
inline int find(int x)
{return (x==fat[x])?x:fat[x]=find(fat[x]);}

int head[MAXN];
struct EDGE
{
    int from,to;
    int val;
    int next;
}edge[MAXM&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to,int val)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].val=val;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}

int has[MAXN];//当前点已经加入的边数
int sec[MAXN],thd[MAXN];
//第二条加入这个点的边的边权，第三条
int sta[19][MAXN],stt[19][MAXN],stnt[19][MAXN];
//树上祖先，连向父节点的边,其它边
void MST()
{
    for(int i=1;i&lt;=n;i++) fat[i]=i;
    sort(e+1,e+m+1,cmp);
    memset(sec,0x3f,sizeof(sec));
    memset(thd,0x3f,sizeof(thd));
    for(int i=1;i&lt;=m;i++)
    {
        int u=e[i].ep1,v=e[i].ep2;
        has[u]++,has[v]++;//加入的边增加了
        if(has[u]==2) sec[u]=e[i].val;//更新
        if(has[v]==2) sec[v]=e[i].val;
        if(has[u]==3) thd[u]=e[i].val;
        if(has[v]==3) thd[v]=e[i].val;
        u=find(u),v=find(v);
        if(u==v) continue;
        add_edge(e[i].ep1,e[i].ep2,e[i].val);
        add_edge(e[i].ep2,e[i].ep1,e[i].val);
        fat[u]=v;//合并集合
    }
}
int depth[MAXN];
inline void dfs(int x,int fath)
{
    depth[x]=depth[fath]+1;
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(y==fath) continue;
        sta[0][y]=x,stt[0][y]=edge[i].val,stnt[0][y]=thd[y];
        for(int j=1;j&lt;=18&amp;&amp;sta[j-1][y];j++)//建立倍增数组
        {
            sta[j][y]=sta[j-1][sta[j-1][y]];
            stt[j][y]=max(stt[j-1][y],stt[j-1][sta[j-1][y]]);
            stnt[j][y]=min(stnt[j-1][y],stnt[j-1][sta[j-1][y]]);
        }
        dfs(y,x);
    }
}
inline int query(int x,int y)
{
    int ntr=min(sec[x],sec[y]),tr=0;
    //非树边先由两个端点加入的第二条边来更新,树边要取最大值所以先赋为0
    if(depth[x]&lt;depth[y]) swap(x,y);//下面是边树上倍增边更新答案
    for(int i=18;i&gt;=0;i--)//跳到相同深度
    {
        if(depth[sta[i][x]]&lt;depth[y]) continue;
        Max(tr,stt[i][x]),Min(ntr,stnt[i][x]);
        x=sta[i][x];
    }
    if(x==y) return max(min(ntr,thd[x]),tr);//如果撞上了
    for(int i=18;i&gt;=0;i--)//同步向上跳
    {
        if(sta[i][x]==sta[i][y]) continue;
        Min(ntr,min(stnt[i][x],stnt[i][y]));
        Max(tr,max(stt[i][x],stt[i][y]));
        x=sta[i][x],y=sta[i][y];
    }
    Max(tr,max(stt[0][x],stt[0][y]));//不要忘记最后还有一步
    Min(ntr,min(thd[x],thd[y]));
    return max(min(ntr,thd[sta[0][x]]),tr);//lca处也要更新
}

signed main()
{
    n=read(),m=read(),q=read();
    for(int i=1;i&lt;=m;i++)
        e[i].ep1=read(),e[i].ep2=read(),e[i].val=read();
    
    MST();//边建立最小生成树边初始化
    stnt[0][1]=thd[1];//注意赋初值
    dfs(1,0);
    while(q--)
    {
        int x=read(),y=read();
        write(query(x,y));
    }

    return 0;
}
</code></pre>
<h3 id="3篝火舞蹈">3.篝火舞蹈</h3>
<p><a href="http://www.sjzezoj.com:9280/problem/51">题面</a></p>
<p><strong>solution</strong></p>
<p>容易想到用Trie树来做（哪里容易想到了……）。</p>
<p>但是普通Trie树无法进行将最后最后一个塞到第一个的操作，然后又发现那个操作相当于是把所有人的位置在三进制表示下不进位+1,所以倒着建立Trie树，即把低位在上面，高位在下面，每次进行第一种操作的时候就打标记(原题要求是从大向小递归，我们的做法相当于是从小向大递归，感性理解)；第二种操作的时候每次只操作当前层最右侧的节点的子节点（相当于是加1要进位的递归下去接着做），最后的时候dfs查询输出即可。</p>
<p>（这玩意可不好想出来）</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1500005;
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(32);
}
inline int Fpow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&amp;1) res*=x;
        x*=x,y&gt;&gt;=1;
    }
    return res;
}

int n,m;
char o[MAXN];
int Ans[MAXN];

int root,cnt_node;
struct Trie
{
    int son[3];
    int num;
    bool flip;
}tree[MAXN];
inline void pushdown(int x)//下放旋转标记
{
    if(!tree[x].flip) return ;
    tree[x].flip=0;
    for(int i=0;i&lt;3;i++)
    {
        int y=tree[x].son[i];
        swap(tree[y].son[1],tree[y].son[2]);
        tree[y].flip^=1;
    }
}
inline int build(int lay,int val,int bs)
{//建树,从低位向高位建立
    int t=++cnt_node;
    if(lay==n) 
    {
        tree[t].num=val;
        return t;
    }
    for(int i=0;i&lt;3;i++)
        tree[t].son[i]=build(lay+1,val+bs*i,bs*3);
    return t;
}
inline void ec(int x)
{//相当于是所有数不进位+1,然后在2变0的枝子上
    if(!x) return;
    swap(tree[x].son[0],tree[x].son[1]);
    swap(tree[x].son[0],tree[x].son[2]);
    pushdown(x);
    ec(tree[x].son[0]);
}
inline void pf()
{
    swap(tree[root].son[1],tree[root].son[2]);
    tree[root].flip^=1;
}
inline void get_ans(int x,int val,int bs)
{
    if(!tree[x].son[0])
    {
        Ans[tree[x].num]=val;
        return ;
    }
    pushdown(x);
    for(int i=0;i&lt;3;i++)
        get_ans(tree[x].son[i],val+bs*i,bs*3);
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n),m=Fpow(3,n);
    scanf(&quot;%s&quot;,o+1);
    int len=strlen(o+1);

    root=build(0,0,1);
    for(int i=1;i&lt;=len;i++)
    {
        if(o[i]=='R') ec(root);
        if(o[i]=='S') pf();
    }
    get_ans(root,0,1);

    for(int i=0;i&lt;m;i++) write(Ans[i]);
    putchar(10);

    return 0;
}
</code></pre>
<h3 id="4在有了">4.（在有了）</h3>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1%E6%BC%94%E8%AE%B2">1.演讲</a></li>
<li><a href="#2%E5%8D%A1%E8%BD%A6%E8%B0%83%E5%BA%A6">2.卡车调度</a></li>
<li><a href="#3%E7%AF%9D%E7%81%AB%E8%88%9E%E8%B9%88">3.篝火舞蹈</a></li>
<li><a href="#4%E5%9C%A8%E6%9C%89%E4%BA%86">4.（在有了）</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lcy09.github.io/post/20201113-summary/">
              <h3 class="post-title">
                2020.11.13考试总结
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lcy09.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
