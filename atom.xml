<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lcy09.github.io</id>
    <title>Lcy&apos;s Blog</title>
    <updated>2020-11-25T06:34:25.948Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lcy09.github.io"/>
    <link rel="self" href="https://lcy09.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://lcy09.github.io/images/avatar.png</logo>
    <icon>https://lcy09.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Lcy&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[P6477 子序列问题 题解]]></title>
        <id>https://lcy09.github.io/post/p6477-solution/</id>
        <link href="https://lcy09.github.io/post/p6477-solution/">
        </link>
        <updated>2020-11-15T14:19:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题面">题面</h3>
<p><a href="https://www.luogu.com.cn/problem/P6477">P6477</a></p>
<h3 id="分析">分析</h3>
<p>枚举位置，发现可以从前一个点的答案更新而来，可以用线段树来维护每个点到当前点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>值，然后再记录下每种元素上次出现的位置，每次答案产生变化的是从当前位置元素上次出现位置的后一个到当前位置，每次记录答案+更新即可。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define ls num&lt;&lt;1
#define rs num&lt;&lt;1|1
using namespace std;
const int MAXN=1000005;
const int mod=1e9+7;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void Add(int &amp;x,int y) {x=(x+y)%mod;}

int n;
int a[MAXN];

int temp[MAXN],len;
void disc()
{
    for(int i=1;i&lt;=n;i++) temp[i]=a[i];
    sort(temp+1,temp+n+1);
    len=unique(temp+1,temp+n+1)-temp-1;
    for(int i=1;i&lt;=n;i++)
        a[i]=lower_bound(temp+1,temp+len+1,a[i])-temp;
}

int lpos[MAXN];
struct SegmentTree
{
    int left,right;
    int val;
    int added;
}tree[MAXN&lt;&lt;2];
inline void pushup(int num)
{tree[num].val=(tree[ls].val+tree[rs].val)%mod;}
inline void build(int num,int l,int r)
{
    tree[num].left=l,tree[num].right=r;
    if(l==r) return ;
    int mid=(l+r)&gt;&gt;1;
    build(ls,l,mid),build(rs,mid+1,r);
}
void pushdown(int num)
{
    if(!tree[num].added) return ;
    int ad=tree[num].added;
    Add(tree[ls].added,ad),Add(tree[rs].added,ad);
    Add(tree[ls].val,ad*(tree[ls].right-tree[ls].left+1));
    Add(tree[rs].val,ad*(tree[rs].right-tree[rs].left+1));
    tree[num].added=0;
}
void add(int num,int l,int r,int adding)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
    {
        Add(tree[num].added,adding);
        Add(tree[num].val,adding*(tree[num].right-tree[num].left+1));
        return ;
    }
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) add(ls,l,r,adding);
    else if(l&gt;mid) add(rs,l,r,adding);
    else add(ls,l,mid,adding),add(rs,mid+1,r,adding);
    pushup(num);
}
int query(int num,int l,int r)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].val;
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return query(ls,l,r);
    else if(l&gt;mid) return query(rs,l,r);
    else return (query(ls,l,mid)+query(rs,mid+1,r))%mod;
}

int Ans[MAXN],ans;

signed main()
{
    n=read();
    for(int i=1;i&lt;=n;i++) a[i]=read();
    
    disc();
    build(1,1,n);
    for(int i=1;i&lt;=n;i++)
    {
        Ans[i]=(Ans[i-1]+query(1,lpos[a[i]]+1,i)*2+i-lpos[a[i]])%mod;//据公式得出
        add(1,lpos[a[i]]+1,i,1),lpos[a[i]]=i;
        Add(ans,Ans[i]);
    }

    printf(&quot;%lld\n&quot;,ans);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.15考试总结]]></title>
        <id>https://lcy09.github.io/post/20201115-summary/</id>
        <link href="https://lcy09.github.io/post/20201115-summary/">
        </link>
        <updated>2020-11-15T14:14:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1铁塔">1.铁塔</h3>
<p><a href="https://www.luogu.com.cn/problem/U140895">题面</a></p>
<p><strong>solution</strong></p>
<p>发现数据是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>能过的，而观察可得贪心不对，所以进行dp.设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个元素最多能分成几段，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个元素的最后一段的最小权值和，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>数组初值赋正无穷，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g_0=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,然后预处理出数组的前缀和暴力遍历前面的所有状态更新即可。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=5005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}

int n;
int a[MAXN],sum[MAXN];
int f[MAXN],g[MAXN];

signed main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read(),sum[i]=sum[i-1]+a[i];

    memset(g,0x3f,sizeof(g));
    g[0]=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;i;j++)
        {
            if(sum[i]-sum[j]&lt;g[j]) continue;//判断是否能更新
            f[i]=max(f[i],f[j]+1);
            g[i]=min(g[i],sum[i]-sum[j]);
        }
    
    write(n-f[n]);

    return 0;
}
</code></pre>
<h3 id="2工作计划">2.工作计划</h3>
<p><a href="https://www.luogu.com.cn/problem/U140902">题面</a></p>
<p><strong>solution</strong></p>
<p>因为工作是随便做的，所以要方便地查询在某个能力值以下最划算的工作，这里用到的是线段树。</p>
<p>发现贪心好像不是很对劲，于是开始考虑dp.</p>
<p>一开始想着做工作是不是和当前的能力值相关，但是发现这样写过于麻烦，然后发现可能在学了某一门课程之后不学了就很优，所以可以在状态中设计时间，即设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>最多做了多少份工作（这里根据个人习惯时间从1开始）。然后对于每门课程按开始时间进行排序，每个课程直接暴力更新所有学完的时间的答案即可。</p>
<p>不要忘记初始是要赋值的。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define ls num&lt;&lt;1
#define rs num&lt;&lt;1|1
using namespace std;
const int MAXS=105;
const int MAXV=10005;
const int inf=0x3f3f3f3f;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline void Max(int &amp;x,int y) {if(y&gt;x) x=y;}
inline void Min(int &amp;x,int y) {if(y&lt;x) x=y;}

int T,s,n;
struct Lesson
{
    int bpos,epos;
    int wb;
}les[MAXS];
bool cmp(Lesson a,Lesson b) {return a.bpos&lt;b.bpos;}

struct SegmentTree
{
    int left,right;
    int Mn;
}tree[MAXV&lt;&lt;2];
void pushup(int num) {tree[num].Mn=min(tree[ls].Mn,tree[rs].Mn);}
void build(int num,int l,int r)
{
    tree[num].left=l,tree[num].right=r;
    if(l==r)
    {
        tree[num].Mn=inf;
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    build(ls,l,mid),build(rs,mid+1,r);
    pushup(num);
}
void change(int num,int pos,int val)
{
    if(tree[num].left==tree[num].right)
    {
        Min(tree[num].Mn,val);
        return ;
    }
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(pos&lt;=mid) change(ls,pos,val);
    else change(rs,pos,val);
    pushup(num);
}
int query(int num,int l,int r)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].Mn;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return query(ls,l,r);
    else if(l&gt;mid) return query(rs,l,r);
    else return min(query(ls,l,mid),query(rs,mid+1,r));
}

int f[MAXV];

signed main()
{
    T=read(),s=read(),n=read();
    for(int i=1;i&lt;=s;i++)
    {
        les[i].bpos=read()+1;
        les[i].epos=les[i].bpos+read()-1;
        les[i].wb=read();
    }
    sort(les+1,les+s+1,cmp);//对课程排序
    build(1,0,10000);//线段树维护工作
    for(int i=1;i&lt;=n;i++)
    {
        int c=read(),d=read();
        change(1,c,d);
    }

    int tmp=query(1,0,1);
    for(int i=1;i&lt;=T;i++) f[i]=i/tmp;//赋初值
    for(int i=1;i&lt;=s;i++)
    {
        if(les[i].epos&gt;=T) continue;//没啥用的超时课程
        tmp=query(1,0,les[i].wb);//找能干的最优的工作
        for(int j=les[i].epos+1;j&lt;=T;j++)//直接暴力更新
            Max(f[j],f[les[i].bpos-1]+(j-les[i].epos)/tmp);
    }

    write(f[T]);
    
    return 0;
}
</code></pre>
<h3 id="3树洞">3.树洞</h3>
<p><a href="https://www.luogu.com.cn/problem/U140903">题面</a></p>
<p><strong>solution</strong></p>
<p>发现这个图很有特点，只有可能是一条链、一个环、一个环加从一个点出来的多个链、一条链加一条支链。</p>
<p>正解是二分答案，然后枚举距离那个特殊点最近的树洞，把该树洞能覆盖的区域全部去掉，图就变成了很多个链，接着直接遍历+更新答案即可。取多次枚举的最小用树洞数与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>相比较，来确定二分区间该怎么移动。</p>
<p>但是我写的时候直接暴力枚举每个点是第一个出现的树洞水过去了……</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=2005;
const int MAXM=4000005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline void Min(int &amp;x,int y) {if(y&lt;x) x=y;}

int n,m,k;

int root;
int head[MAXN];
struct EDGE
{
    int from,to;
    int next;
}edge[MAXM&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}
int du[MAXN];

bool vis[MAXN];
int dis[MAXN];
void mark(int x,int lim)//标记枚举出来的树洞能覆盖的点
{
    vis[x]=1;
    if(dis[x]==lim) return ;
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        Min(dis[y],dis[x]+1);
        if(vis[y]) continue;
        mark(y,lim);
    }
}
int get_sz(int x)//找出每个链的大小
{
    int sz=1;
    vis[x]=1;
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(vis[y]) continue;
        sz+=get_sz(y);
    }
    return sz;
}
bool check(int lim)
{
    for(int i=1;i&lt;=n;i++)//暴力不已……
    {
        memset(dis,0x3f,sizeof(dis));
        memset(vis,0,sizeof(vis));
        dis[i]=0,vis[i]=1;
        mark(i,lim);
        int res=1;
        for(int j=1;j&lt;=n;j++)
        {
            if(vis[j]) continue;
            res+=((get_sz(j)-1)/(lim&lt;&lt;1|1)+1);
        }
        if(res&lt;=k) return 1;
    }
    return 0;
}

int ans;

int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i&lt;=m;i++)
    {
        int u=read(),v=read();
        add_edge(u,v),add_edge(v,u);
        if(++du[u]&gt;2) root=u;
        if(++du[v]&gt;2) root=v;
    }

    if(!root)//特判
    {
        write(((n-1)/k+1)&gt;&gt;1);
        return 0;
    }
    int le=0,ri=n;
    while(le&lt;=ri)
    {
        int mid=(le+ri)&gt;&gt;1;
        if(check(mid)) ans=mid,ri=mid-1;
        else le=mid+1;
    }

    write(ans);

    return 0;
}
</code></pre>
<p>总的来说这次考试不是很难，本人考场上3个小时A掉了T1T2，T3也拿到了80分。不知道是这次运气好还是真的能力有所提高？总之这个成绩还是很令人振奋的，继续加油啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.14考试总结]]></title>
        <id>https://lcy09.github.io/post/20201114-summary/</id>
        <link href="https://lcy09.github.io/post/20201114-summary/">
        </link>
        <updated>2020-11-15T14:12:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1演讲">1.演讲</h3>
<p><strong>题目描述</strong></p>
<p>大洋彼岸的没事干国有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个人（编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ）闲着没事要竞选总统。</p>
<p>为了显示其他候选人的无法胜任，这些人需要上台演讲。</p>
<p>第一天 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号候选人开始发言，把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>号狠狠地D了一通。</p>
<p>如果某天<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>号候选人 D 了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 号，那么下一天就由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>号候选人发言，且这一天他要 D 的人是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 号。</p>
<p>没事干国的人都很无聊，所以演讲将无穷无尽地持续下去。那么第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>天发言的会是几号呢？</p>
<p><strong>输入格式</strong></p>
<p>第一行一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">n,d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span>——有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个候选人，询问第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 天发言的候选人。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，其中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>输出格式</strong></p>
<p>一行一个数表示答案。</p>
<p>数据规模与约定</p>
<p>对于所有数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>600</mn><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><mi>d</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">2≤n≤600，1≤d≤10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>；</p>
<p>保证不存在自己 D 自己的情况，输入中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g_{i,i}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">≠</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">i≠j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1≤g_{i,j}≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.922078em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p>发现相邻两个元素构成的二元组最多只可能有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个，所以暴力map来找循环节即可。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=605;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,d;
int g[MAXN][MAXN];

int ord[MAXN*MAXN*2],len,pos;
map&lt;int,int&gt;mp;

signed main()
{
    n=read(),d=read();
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            g[i][j]=read();
    
    ord[++len]=1,ord[++len]=2,mp[1002]=1;
    for(int i=3;i&lt;=n*n;i++)
    {
        ord[len=i]=g[ord[i-1]][ord[i-2]];
        int tmp=ord[i-1]*1000+ord[i];
        if(mp[tmp]) 
        {
            len-=2,pos=mp[tmp];
            break;
        }
        else mp[tmp]=i-1;
    }

    if(d&lt;=len) printf(&quot;%lld\n&quot;,ord[d]);
    else
    {
        d-=(pos-1);
        d%=(len-pos+1);
        if(!d) printf(&quot;%lld\n&quot;,ord[len]);
        else printf(&quot;%lld\n&quot;,ord[d+pos-1]);
    }
    
    return 0;
}
</code></pre>
<h3 id="2卡车调度">2.卡车调度</h3>
<p><a href="http://www.sjzezoj.com:9280/problem/50">题面</a></p>
<p><strong>solution</strong></p>
<p>77分纪念版写法</p>
<p>建立最小生成树进行树剖，然后记录每个点连接的轻边边权最小值和非树边最小值。每次查询是分成很多段的，先标记路径并计算链上的边的答案，每段的首尾端点暴力更新答案，中间查询轻边和非树边进行更新即可。</p>
<p>（这屑做法写了7.3k我居然考场上yy出来了……）</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define ls num&lt;&lt;1
#define rs num&lt;&lt;1|1
using namespace std;
const int MAXN=300005;
const int MAXM=1000005;
const int inf=0x3f3f3f3f3f3f3f3f;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline void Min(int &amp;x,int y) {if(y&lt;x) x=y;}
inline void Max(int &amp;x,int y) {if(y&gt;x) x=y;}

int n,m,q;
struct ED
{
    int ep1,ep2;
    int val;
    bool ontr;//是否在树上
}e[MAXM];
bool cmp(ED a,ED b) {return a.val&lt;b.val;}

int head[MAXN];
struct EDGE
{
    int from,to;
    int val;
    int next;
}edge[MAXM&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to,int val)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].val=val;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}

int fat[MAXN];
int find(int x)
{
    if(x==fat[x]) return x;
    return fat[x]=find(fat[x]);
}
void Kruskal()
{
    for(int i=1;i&lt;=n;i++) fat[i]=i;
    sort(e+1,e+m+1,cmp);
    int ecnt=0;
    for(int i=1;i&lt;=m;i++)
    {
        int u=find(e[i].ep1),v=find(e[i].ep2);
        if(u==v) continue;
        fat[u]=v;
        add_edge(e[i].ep1,e[i].ep2,e[i].val);
        add_edge(e[i].ep2,e[i].ep1,e[i].val);
        ecnt++,e[i].ontr=1;
        if(ecnt==n-1) break;
    }
}

int dfs_cnt;
int fa[MAXN],son[MAXN];
int dfn[MAXN],rev[MAXN],depth[MAXN];
int siz[MAXN],top[MAXN],bot[MAXN];
int ev[MAXN],Mle[MAXN],nontr[MAXN];
//代表每个点的返祖边,每个点的轻边,每个点的非树边
//直接路径上查最大,烂树杈子查最小
inline void dfs_son(int x,int fath)
{
    depth[x]=depth[fa[x]=fath]+(siz[x]=1);
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(y==fath) continue;
        ev[y]=edge[i].val;
        dfs_son(y,x);
        siz[x]+=siz[y];
        if(siz[y]&gt;siz[son[x]]) son[x]=y;
    }
}
inline void dfs_chain(int x,int tp)
{
    rev[dfn[x]=++dfs_cnt]=x;
    top[x]=tp;
    if(son[x]) dfs_chain(son[x],tp),bot[x]=bot[son[x]];
    else bot[x]=x;//递归记录链底
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(dfn[y]) continue;
        dfs_chain(y,y);
    }
}
struct SegmentTree
{
    int left,right;
    int mk,EV,Mle,nontr;
    int willbe;
}tree[MAXN&lt;&lt;2];
inline void pushup(int num)
{
    tree[num].EV=max(tree[ls].EV,tree[rs].EV);
    tree[num].Mle=min(tree[ls].Mle,tree[rs].Mle);
    tree[num].nontr=min(tree[ls].nontr,tree[rs].nontr);
}
inline void build(int num,int l,int r)
{
    tree[num].left=l,tree[num].right=r;
    tree[num].willbe=inf;
    if(l==r)
    {
        tree[num].EV=ev[rev[l]];
        tree[num].Mle=Mle[rev[l]];
        tree[num].nontr=nontr[rev[l]];
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    build(ls,l,mid),build(rs,mid+1,r);
    pushup(num);
}
inline void pushdown(int num)
{
    if(tree[num].willbe&gt;1e10) return ;
    int wb=tree[num].willbe;
    tree[ls].willbe=tree[rs].willbe=wb;
    tree[ls].mk=tree[rs].mk=wb;
    tree[num].willbe=inf;
}
inline void change(int num,int l,int r,int wb)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
    {
        tree[num].mk=tree[num].willbe=wb;
        return ;
    }
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) change(ls,l,r,wb);
    else if(l&gt;mid) change(rs,l,r,wb);
    else
        change(ls,l,mid,wb),change(rs,mid+1,r,wb);
    tree[num].mk=tree[ls].mk|tree[rs].mk;
}
inline int querymk(int num,int pos)
{
    if(tree[num].left==tree[num].right)
        return tree[num].mk;
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(pos&lt;=mid) return querymk(ls,pos);
    else return querymk(rs,pos);
}
inline int queryev(int num,int l,int r)
{
    if(l&gt;r) return 0;
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].EV;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return queryev(ls,l,r);
    else if(l&gt;mid) return queryev(rs,l,r);
    else return max(queryev(ls,l,mid),queryev(rs,mid+1,r));
}
inline int querymle(int num,int l,int r)
{
    if(l&gt;r) return inf;
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].Mle;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return querymle(ls,l,r);
    else if(l&gt;mid) return querymle(rs,l,r);
    else return min(querymle(ls,l,mid),querymle(rs,mid+1,r));
}
inline int querynt(int num,int l,int r)
{
    if(l&gt;r) return inf;
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].nontr;
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return querynt(ls,l,r);
    else if(l&gt;mid) return querynt(rs,l,r);
    else return min(querynt(ls,l,mid),querynt(rs,mid+1,r));
}

inline void update(int x,int y,int wb)
{
    while(top[x]!=top[y])
    {
        if(depth[top[x]]&lt;depth[top[y]]) swap(x,y);
        change(1,dfn[top[x]],dfn[x],wb);
        x=fa[top[x]];
    }
    if(depth[x]&gt;depth[y]) swap(x,y);
    change(1,dfn[x],dfn[y],wb);
}
inline int get_m(int x)
{
    int res=nontr[x];
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(querymk(1,dfn[y])) continue;
        Min(res,edge[i].val);
    }
    return res;
}
inline int ask(int x,int y)
{
    update(x,y,1);
    int tx=x,ty=y,res1=0,res2=inf;
    while(top[tx]!=top[ty])
    {
        if(depth[top[tx]]&lt;depth[top[ty]]) swap(tx,ty);
        Max(res1,queryev(1,dfn[top[tx]],dfn[tx]));
        tx=fa[top[tx]];
    }
    if(depth[tx]&gt;depth[ty]) swap(tx,ty);
    Max(res1,queryev(1,dfn[tx]+1,dfn[ty]));

    tx=x,ty=y;
    while(top[tx]!=top[ty])
    {
        if(depth[top[tx]]&lt;depth[top[ty]]) swap(tx,ty);
        Min(res2,querymle(1,dfn[top[tx]]+1,dfn[tx]-1));
        Min(res2,querynt(1,dfn[top[tx]]+1,dfn[tx]-1));
        Min(res2,get_m(top[tx])),Min(res2,get_m(tx));
        tx=fa[top[tx]];
    }
    if(depth[tx]&gt;depth[ty]) swap(tx,ty);
    Min(res2,querymle(1,dfn[tx]+1,dfn[ty]-1));
    Min(res2,querynt(1,dfn[tx]+1,dfn[ty]-1));
    Min(res2,get_m(tx)),Min(res2,get_m(ty));

    update(x,y,0);
    if(res2&gt;1e10) return -1;
    return max(res1,res2);
}

signed main()
{
    n=read(),m=read(),q=read();
    for(int i=1;i&lt;=m;i++)
        e[i].ep1=read(),e[i].ep2=read(),e[i].val=read();

    Kruskal();
    dfs_son(1,0),dfs_chain(1,1);
    memset(Mle,0x3f,sizeof(Mle));
    memset(nontr,0x3f,sizeof(nontr));
    for(int i=1;i&lt;=m;i++)
    {
        if(e[i].ontr) continue;
        Min(nontr[e[i].ep1],e[i].val);
        Min(nontr[e[i].ep2],e[i].val);
    }
    for(int x=1;x&lt;=n;x++)
    {
        if(top[x]!=x) continue;
        for(int i=head[x];i;i=edge[i].next)
        {
            int y=edge[i].to;
            if(y!=fa[x]) continue;
            Min(Mle[x],edge[i].val),Min(Mle[y],edge[i].val);
            break;
        }
    }
    build(1,1,n);

    while(q--)
    {
        int x=read(),y=read();
        write(ask(x,y));
    }

    return 0;
}
</code></pre>
<p>正解</p>
<p>首先考虑二分答案,发现两个点之间的简单路径一定在整张图的最小生成树上或者可以转化到最小生成树上，所以先建立出整张图的最小生成树。</p>
<p>在根据边权对边排序后，越早加入的边越优，发现在一条链上，点的度数只有1和2两种，所以只需要记录下每个点的度数大于1和2瞬间的加入边权，然后存在倍增数组里，每次询问就像找LCA一样倍增向上跳，边跳边更新答案，即用链的两个端点的第二条加入边和链上其它点的第三条加入边来更新那个伸出去的道路的答案。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=300005;
const int MAXM=1000005;
const int inf=0x3f3f3f3f3f3f3f3f;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline void Min(int &amp;x,int y) {if(y&lt;x) x=y;}
inline void Max(int &amp;x,int y) {if(y&gt;x) x=y;}

int n,m,q;

struct ED
{
    int ep1,ep2;
    int val;
}e[MAXM];
bool cmp(ED a,ED b) {return a.val&lt;b.val;}
int fat[MAXN];
inline int find(int x)
{return (x==fat[x])?x:fat[x]=find(fat[x]);}

int head[MAXN];
struct EDGE
{
    int from,to;
    int val;
    int next;
}edge[MAXM&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to,int val)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].val=val;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}

int has[MAXN];//当前点已经加入的边数
int sec[MAXN],thd[MAXN];
//第二条加入这个点的边的边权，第三条
int sta[19][MAXN],stt[19][MAXN],stnt[19][MAXN];
//树上祖先，连向父节点的边,其它边
void MST()
{
    for(int i=1;i&lt;=n;i++) fat[i]=i;
    sort(e+1,e+m+1,cmp);
    memset(sec,0x3f,sizeof(sec));
    memset(thd,0x3f,sizeof(thd));
    for(int i=1;i&lt;=m;i++)
    {
        int u=e[i].ep1,v=e[i].ep2;
        has[u]++,has[v]++;//加入的边增加了
        if(has[u]==2) sec[u]=e[i].val;//更新
        if(has[v]==2) sec[v]=e[i].val;
        if(has[u]==3) thd[u]=e[i].val;
        if(has[v]==3) thd[v]=e[i].val;
        u=find(u),v=find(v);
        if(u==v) continue;
        add_edge(e[i].ep1,e[i].ep2,e[i].val);
        add_edge(e[i].ep2,e[i].ep1,e[i].val);
        fat[u]=v;//合并集合
    }
}
int depth[MAXN];
inline void dfs(int x,int fath)
{
    depth[x]=depth[fath]+1;
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(y==fath) continue;
        sta[0][y]=x,stt[0][y]=edge[i].val,stnt[0][y]=thd[y];
        for(int j=1;j&lt;=18&amp;&amp;sta[j-1][y];j++)//建立倍增数组
        {
            sta[j][y]=sta[j-1][sta[j-1][y]];
            stt[j][y]=max(stt[j-1][y],stt[j-1][sta[j-1][y]]);
            stnt[j][y]=min(stnt[j-1][y],stnt[j-1][sta[j-1][y]]);
        }
        dfs(y,x);
    }
}
inline int query(int x,int y)
{
    int ntr=min(sec[x],sec[y]),tr=0;
    //非树边先由两个端点加入的第二条边来更新,树边要取最大值所以先赋为0
    if(depth[x]&lt;depth[y]) swap(x,y);//下面是边树上倍增边更新答案
    for(int i=18;i&gt;=0;i--)//跳到相同深度
    {
        if(depth[sta[i][x]]&lt;depth[y]) continue;
        Max(tr,stt[i][x]),Min(ntr,stnt[i][x]);
        x=sta[i][x];
    }
    if(x==y) return max(min(ntr,thd[x]),tr);//如果撞上了
    for(int i=18;i&gt;=0;i--)//同步向上跳
    {
        if(sta[i][x]==sta[i][y]) continue;
        Min(ntr,min(stnt[i][x],stnt[i][y]));
        Max(tr,max(stt[i][x],stt[i][y]));
        x=sta[i][x],y=sta[i][y];
    }
    Max(tr,max(stt[0][x],stt[0][y]));//不要忘记最后还有一步
    Min(ntr,min(thd[x],thd[y]));
    return max(min(ntr,thd[sta[0][x]]),tr);//lca处也要更新
}

signed main()
{
    n=read(),m=read(),q=read();
    for(int i=1;i&lt;=m;i++)
        e[i].ep1=read(),e[i].ep2=read(),e[i].val=read();
    
    MST();//边建立最小生成树边初始化
    stnt[0][1]=thd[1];//注意赋初值
    dfs(1,0);
    while(q--)
    {
        int x=read(),y=read();
        write(query(x,y));
    }

    return 0;
}
</code></pre>
<h3 id="3篝火舞蹈">3.篝火舞蹈</h3>
<p><a href="http://www.sjzezoj.com:9280/problem/51">题面</a></p>
<p><strong>solution</strong></p>
<p>容易想到用Trie树来做（哪里容易想到了……）。</p>
<p>但是普通Trie树无法进行将最后最后一个塞到第一个的操作，然后又发现那个操作相当于是把所有人的位置在三进制表示下不进位+1,所以倒着建立Trie树，即把低位在上面，高位在下面，每次进行第一种操作的时候就打标记(原题要求是从大向小递归，我们的做法相当于是从小向大递归，感性理解)；第二种操作的时候每次只操作当前层最右侧的节点的子节点（相当于是加1要进位的递归下去接着做），最后的时候dfs查询输出即可。</p>
<p>（这玩意可不好想出来）</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1500005;
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
    putchar(32);
}
inline int Fpow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&amp;1) res*=x;
        x*=x,y&gt;&gt;=1;
    }
    return res;
}

int n,m;
char o[MAXN];
int Ans[MAXN];

int root,cnt_node;
struct Trie
{
    int son[3];
    int num;
    bool flip;
}tree[MAXN];
inline void pushdown(int x)//下放旋转标记
{
    if(!tree[x].flip) return ;
    tree[x].flip=0;
    for(int i=0;i&lt;3;i++)
    {
        int y=tree[x].son[i];
        swap(tree[y].son[1],tree[y].son[2]);
        tree[y].flip^=1;
    }
}
inline int build(int lay,int val,int bs)
{//建树,从低位向高位建立
    int t=++cnt_node;
    if(lay==n) 
    {
        tree[t].num=val;
        return t;
    }
    for(int i=0;i&lt;3;i++)
        tree[t].son[i]=build(lay+1,val+bs*i,bs*3);
    return t;
}
inline void ec(int x)
{//相当于是所有数不进位+1,然后在2变0的枝子上
    if(!x) return;
    swap(tree[x].son[0],tree[x].son[1]);
    swap(tree[x].son[0],tree[x].son[2]);
    pushdown(x);
    ec(tree[x].son[0]);
}
inline void pf()
{
    swap(tree[root].son[1],tree[root].son[2]);
    tree[root].flip^=1;
}
inline void get_ans(int x,int val,int bs)
{
    if(!tree[x].son[0])
    {
        Ans[tree[x].num]=val;
        return ;
    }
    pushdown(x);
    for(int i=0;i&lt;3;i++)
        get_ans(tree[x].son[i],val+bs*i,bs*3);
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n),m=Fpow(3,n);
    scanf(&quot;%s&quot;,o+1);
    int len=strlen(o+1);

    root=build(0,0,1);
    for(int i=1;i&lt;=len;i++)
    {
        if(o[i]=='R') ec(root);
        if(o[i]=='S') pf();
    }
    get_ans(root,0,1);

    for(int i=0;i&lt;m;i++) write(Ans[i]);
    putchar(10);

    return 0;
}
</code></pre>
<h3 id="4在有了">4.（在有了）</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.13考试总结]]></title>
        <id>https://lcy09.github.io/post/20201113-summary/</id>
        <link href="https://lcy09.github.io/post/20201113-summary/">
        </link>
        <updated>2020-11-15T14:03:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1gcd">1.gcd</h3>
<p><strong>题目描述</strong></p>
<p>给一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列，定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>y</mi><mi>z</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>…</mo><msub><mi>a</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lyz (i,j)=gcd(a_i, a_{i+1}, a_{i+2}\dots a_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi></mrow><mi>n</mi></msubsup><mi>l</mi><mi>y</mi><mi>z</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^n \sum\limits_{j=i}^n lyz(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.465174em;vertical-align:-1.113777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.113777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>.</p>
<p><strong>输入格式</strong></p>
<p>第一行一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 。</p>
<p>第二行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，空格分隔，表示序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>输出格式</strong></p>
<p>一个整数表示答案<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\pmod{10^9+7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>的结果。</p>
<p><strong>注意事项</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>100000</mn><mo separator="true">,</mo><mn>1</mn><mo>⩽</mo><msub><mi>a</mi><mi>i</mi></msub><mo>⩽</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">n\leqslant 100000,1\leqslant a_i\leqslant 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78667em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p>因为从一个位置开始向右直到序列末尾的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span></span></span></span>值只会变化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>次，所以可以枚举左端点，然后二分出来每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span></span></span></span>变化的位置，通过ST表进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>(???或者log)查询来统计答案。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=100005;
const int mod=1000000007;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline int gcd(int x,int y)
{
    return y?gcd(y,x%y):x;
}

int n;
int a[MAXN];
int ans;

int st[18][MAXN];
//从当前位置开始的长度为2^i的区间gcd
void st_init()
{
    for(int i=1;i&lt;=n;i++) st[0][i]=a[i];
    for(int j=1;(1ll&lt;&lt;j)&lt;=n;j++)
        for(int i=1;i+(1ll&lt;&lt;j)-1&lt;=n;i++)
            st[j][i]=gcd(st[j-1][i],st[j-1][i+(1ll&lt;&lt;(j-1))]);
}
int query(int l,int r)
{
    int k=(int)(log(r-l+1)/log(2));
    return gcd(st[k][l],st[k][r-(1ll&lt;&lt;k)+1]);
}
void opt(int ep)//左端点
{
    int rp=ep;
    int now=st[0][ep];
    while(rp&lt;=n)//注意取等
    {
        int lastpos=rp-1;
        int le=rp,ri=n;
        while(le&lt;=ri)//二分出来的是最后一个与当前gcd相等的位置
        {
            int mid=(le+ri)&gt;&gt;1;
            if(query(ep,mid)==now) 
                rp=mid,le=mid+1;
            else ri=mid-1;
        }
        ans=(ans+query(ep,rp)*(rp-lastpos))%mod;//统计答案
        rp++,now=query(ep,rp);//右移
    }
}

signed main()
{
    n=read();
    for(int i=1;i&lt;=n;i++) 
        a[i]=read();
    
    st_init();
    for(register int i=1;i&lt;=n;i++)
        opt(i);//枚举左端点

    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<h3 id="2or_and">2.or_and</h3>
<p><strong>题目描述</strong></p>
<p>求:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup><mi>i</mi><mi mathvariant="normal">∣</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">\sum\limits_{i=0}^n \sum\limits_{j=0}^m i|j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.465174em;vertical-align:-1.113777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.113777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>.</p>
<p><strong>输入格式</strong></p>
<p>输入两个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>.</p>
<p><strong>输出格式</strong></p>
<p>一个整数表示答案<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\pmod{10^9+7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>的结果。</p>
<p><strong>注意事项</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>⩽</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">1\leqslant n,m\leqslant 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83111em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p>将答案拆成两部分，一部分是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>)</mo><mo>×</mo><mo>(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(\sum\limits_{i=0}^ni)\times(m+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>另一部分是对于每个二进制位在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>中出现的次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>,乘上该二进制位对应的权值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span></span></span></span>,再乘上其在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>中没出现的次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>(上面用一般化表达太累不想写)</p>
<p>注意处处取模，且在等差数列求和过程中的除法要用逆元。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int mod=1000000007;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(x&lt;0) putchar('-'),x=-x;
    do s[++len]=x%10,x/=10;while(x);
    while(len) putchar('0'|s[len--]);
}
inline int Fpow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&amp;1) res=(res*x)%mod;
        x=(x*x)%mod,y&gt;&gt;=1;
    }
    return res;
}
inline void Mul(int &amp;x,int y)
{
    x%=mod,y%=mod;
    x=(x*y)%mod;
}

int n,m;
int ans=1;
inline int get_num(int bt,int val)//通过观察找的规律
{
    if(val&lt;(1ll&lt;&lt;bt)) return 0;
    bt++;
    int res=(val/(1ll&lt;&lt;bt))*(1ll&lt;&lt;(bt-1));
    val%=(1ll&lt;&lt;bt);
    res+=max(0ll,val-(1ll&lt;&lt;(bt-1))+1);
    return res;
}

signed main()
{
    n=read(),m=read();
    Mul(ans,n),Mul(ans,(n+1)),Mul(ans,Fpow(2,mod-2));
    Mul(ans,m+1);

    for(int i=0;i&lt;=61;i++)
    {
        int cntn=get_num(i,n),cntm=get_num(i,m);
        int res=1;
        Mul(res,n+1-cntn),Mul(res,cntm),Mul(res,1ll&lt;&lt;i);
        ans=(ans+res)%mod;
    }

    write(ans);

    return 0;
}
</code></pre>
<h3 id="3at2366-prefix-median">3.AT2366 Prefix Median</h3>
<p>这屑题让我咋写题解啊……</p>
<p>粘一个链接</p>
<p><a href="https://www.cnblogs.com/thedreammaker/p/11331027.html">AT2366题解</a></p>
<p>个人的感性理解就是先将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>数组进行排序，然后发现前面的数范围很大，越往后范围越小，到最后一个数肯定就只剩下一个可以选了。</p>
<p>所以倒着dp,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>已经选了，然后当前选的在可选范围里比它小的有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个，比它大的有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个，然后往前进行范围扩展，同时把所有包含在扩展后范围里的小区间都进行刷表更新。</p>
<p>（算了本人也不太明白直接粘代码吧）</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=202;
const int mod=1e9+7;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,m;
int a[MAXN];

int f[MAXN][MAXN][MAXN];
//表示从i到n都已经选完了,小于当前bi的选择有j个,大于的有k个的方案数
void Add(int &amp;x,int y)
{
    x=(x+y)%mod;
}
int ans;

signed main()
{
    n=read(),m=(n&lt;&lt;1)-1;
    for(int i=1;i&lt;=m;i++) a[i]=read();

    sort(a+1,a+m+1);
    f[n][0][0]=1;//赋初值
    for(int i=n;i&gt;1;i--)
        for(int j=0;j&lt;=m;j++)//枚举
            for(int k=0;k&lt;=m;k++)
            {
                if(!f[i][j][k]) continue;//如果没被更新过一定不合法所以跳过
                int x=j+(a[i-1]!=a[i]),y=k+(a[m-i+2]!=a[m-i+1]);
                //扩展范围
                Add(f[i-1][x][y],f[i][j][k]);
                //更新最大范围
                //以下两个循环均是从大范围向小范围进行更新
                for(int o=0;o&lt;x;o++)
                    Add(f[i-1][o][y+1],f[i][j][k]);
                for(int o=0;o&lt;y;o++)
                    Add(f[i-1][x+1][o],f[i][j][k]);
            }
    for(int i=0;i&lt;=m;i++)
        for(int j=0;j&lt;=m;j++)
            Add(ans,f[1][i][j]);//统计最终答案
    
    printf(&quot;%lld\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="4beautiful">4.beautiful</h3>
<p><strong>题目描述</strong></p>
<p>括号实在是太美了。艾斯洛克希望你送给她一个长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的合法括号序列，保证<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>是偶数。</p>
<p>你在序列的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 位放左括号的代价为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，放右括号的代价为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。艾斯洛克不想让你太麻烦，所以希望你支付最小的代价。不过才不是担心你呢！真的不是哦！</p>
<p><strong>输入格式</strong></p>
<p>第一行输入一个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>。</p>
<p>第二行输入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个整数表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>第三行输入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个整数表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数表示答案。</p>
<p><strong>提示说明</strong></p>
<p>子任务1, 20分：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>N</mi><mo>⩽</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">1\leqslant N \leqslant 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8200000000000001em;vertical-align:-0.13667em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>;</p>
<p>子任务2, 30分：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>N</mi><mo>⩽</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1\leqslant N\leqslant2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8200000000000001em;vertical-align:-0.13667em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>;</p>
<p>子任务3,50分：无特殊限制。</p>
<p>对于所有测试数据，满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>N</mi><mo>⩽</mo><mn>300000</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>⩽</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>⩽</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\leqslant N\leqslant 300000,-10^9\leqslant a_i,b_i\leqslant 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8200000000000001em;vertical-align:-0.13667em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p>鉴于是T4所以当时懒得想了直接打了个爆搜，结果老师没传全数据导致一帮<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>暴力dp人A了????</p>
<p>这里粘个正解。</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clenovo%5CDocuments%5CGridea%5Cpost-images%5Cbeautiful.png" alt="" loading="lazy"></figure>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define ls num&lt;&lt;1
#define rs num&lt;&lt;1|1
using namespace std;
const int MAXN=300005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n;
int cost[MAXN][2];
int ord[MAXN];
bool cmp(int x,int y)
{
    return cost[x][1]&lt;cost[y][1];
}
int ans;

struct SegmentTree
{
    int left,right;
    int Min;
    int added;
}tree[MAXN&lt;&lt;2];
inline void pushup(int num)
{
    tree[num].Min=min(tree[ls].Min,tree[rs].Min);
}
inline void build(int num,int l,int r)
{
    tree[num].left=l,tree[num].right=r;
    if(l==r)
    {
        tree[num].Min=(l&gt;&gt;1);
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    build(ls,l,mid),build(rs,mid+1,r);
    pushup(num);
}
inline void pushdown(int num)
{
    if(!tree[num].added) return ;
    int ad=tree[num].added;
    tree[ls].Min+=ad,tree[rs].Min+=ad;
    tree[ls].added+=ad,tree[rs].added+=ad;
    tree[num].added=0;
}
inline void add(int num,int l,int r,int adding)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
    {
        tree[num].Min+=adding,tree[num].added+=adding;
        return ;
    }
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) add(ls,l,r,adding);
    else if(l&gt;mid) add(rs,l,r,adding);
    else add(ls,l,mid,adding),add(rs,mid+1,r,adding);
    pushup(num);
}
inline int query(int num,int l,int r)
{
    if(tree[num].left==l&amp;&amp;tree[num].right==r)
        return tree[num].Min;
    pushdown(num);
    int mid=(tree[num].left+tree[num].right)&gt;&gt;1;
    if(r&lt;=mid) return query(ls,l,r);
    else if(l&gt;mid) return query(rs,l,r);
    else return min(query(ls,l,mid),query(rs,mid+1,r));
}


signed main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        cost[i][0]=read(),ans+=cost[i][0];
    for(int i=1;i&lt;=n;i++)
        cost[i][1]=read()-cost[i][0],ord[i]=i;

    build(1,1,n);
    sort(ord+1,ord+n+1,cmp);
    for(int i=1,cnt=0;i&lt;=n;i++)
    {
        if(query(1,ord[i],n)&lt;=0) continue;
        cnt++;
        ans+=cost[ord[i]][1];
        add(1,ord[i],n,-1);
        if(cnt==(n&gt;&gt;1)) break;
    }

    printf(&quot;%lld\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="5消棋子">5.消棋子</h3>
<p><a href="http://www.sjzezoj.com:9280/problem/44">消棋子</a></p>
<p><strong>solution</strong></p>
<p>观察发现从中间开始消最快，尤其是正中间。而每一列都是互不影响的所以单独进行考虑。输入的时候把相同颜色的段抽象成数字，进而每一列变成一个数列，从正中间开始向两边找，找到第一个棋子数量大于1的段之后停止。然后看这两个点分别往边上消和中间消取最大值即是答案。</p>
<p>注意判断无解的情况。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXM=105;
const int MAXN=10005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,m;
int a[MAXN],len;//某个值是0则为长度为1的段,是1则是长度大于1的段
int ans;

int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
    {
        string temp;
        bool flag=0;
        cin&gt;&gt;temp;
        len=0;
        a[++len]=0;
        for(int j=1;j&lt;temp.size();j++)
        {
            if(temp[j]==temp[j-1]) flag=a[len]=1;
            else a[++len]=0;
        }
        if(!flag) continue;//都是长度为1的不用消

        int pl=(len+1)&gt;&gt;1,pr=(len+1)&gt;&gt;1;//初始位置在中间
        while(pl)//左边的向左移动去找
        {
            if(a[pl]) break;
            pl--;
        }
        while(pr&lt;=len)//右边的右移去找
        {
            if(a[pr]&amp;&amp;pl!=pr) break;
            pr++;
        }
        if(!pl) ans+=pr;//左边的移出去了
        else if(pr&gt;len) ans+=len-pl+1;//右边的移出去了
        else if(pl+len-pr&gt;=pr-pl+1) ans+=(len&gt;&gt;1)+1;
        //判断答案是两个都往边上走还是中间走
        else ans+=pr-pl+1;
    }

    cout&lt;&lt;ans&lt;&lt;endl;

    return 0;
}
</code></pre>
<h3 id="6机房的新生活委员">6.机房的新生活委员</h3>
<p><strong>题目描述</strong></p>
<p>大家都知道，R_rank_Pyram在两次搜索专题比赛中都雄踞排行榜首位。林老师会给他个什么官当当呢？其实讲真，老师也很矛盾...直到有一天，lgj发现机房的一些日用品需要更新了，比如扫把啦，抹布啦，畚斗啦etc...那不然就奖励R_rank_Pyram同学当机房的新生活委员吧！</p>
<p>新官上任三把火，R_rank_Pyram一上台就要为机房购置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>种日用品（编号从1到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>），R_rank_Pyram会选择在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 家商店购买。由于R_rank_Pyram不想带着买好的商品在商店间穿梭，他每次从机房出发到一家店铺买完东西后，会把东西带回机房，再出发去另一家店铺...</p>
<p>已知从机房往返第i家店铺的交通费为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>e</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">fee_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,并且每件商品在不同店铺购买价格也不同，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件商品在第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>家店铺的价格为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">cost_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。精打细算的生活委员想知道，购买这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>件商品最少需要花多少钱？</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>，表示店铺数量和需要购买的物品种类数。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行第一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>e</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">fee_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个正整数，依次表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">cost_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>输出格式</strong></p>
<p>输出一个正整数，即最小花费。</p>
<p><strong>数据规模</strong></p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">40\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">%</span></span></span></span>的数据：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>10</mn><mo separator="true">,</mo><mi>m</mi><mo>⩽</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">n\leqslant 10,m\leqslant10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>;</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span>的数据: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">n\leqslant50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>;</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span>的数据： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>n</mi><mo>⩽</mo><mn>100</mn><mo separator="true">,</mo><mn>1</mn><mo>⩽</mo><mi>m</mi><mo>⩽</mo><mn>16</mn><mi mathvariant="normal">，</mi><mn>1</mn><mo>⩽</mo><mi>f</mi><mi>e</mi><msub><mi>e</mi><mi>i</mi></msub><mo>⩽</mo><mn>1000000</mn><mi mathvariant="normal">，</mi><mn>1</mn><mo>⩽</mo><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>⩽</mo><mn>1000000</mn></mrow><annotation encoding="application/x-tex">1\leqslant n\leqslant100,1\leqslant m\leqslant16，1\leqslant fee_i\leqslant 1000000，1\leqslant cost_{i,j}\leqslant 1000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9227779999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p>看到物品数很小，所以可以进行状压dp.然后考虑这个路费怎么处理。</p>
<p>我们可以先设另一个辅助数组来表示全选的情况的最小花费，转移是上一家商店已经计算出的答案均加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>e</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">fee_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.然后在全选的数组上进行经典的“去一位”状压dp转移，注意这个转移是从上一家店的答案和当前商店必选的答案同时转移，最后当前商店的答案从必选当前商店和上一家商店的答案取较小值。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=105;
const int MAXM=17;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void Min(int &amp;x,int y)
{
    if(y&lt;x) x=y;
}

int n,m;
int fee[MAXN];
int cost[MAXN][MAXM];

int f[MAXN][(1&lt;&lt;MAXM)+5][2];
int ans=0x3f3f3f3f;

int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
    {
        fee[i]=read();
        for(int j=1;j&lt;=m;j++) cost[i][j]=read();
    }

    memset(f,0x3f,sizeof(f));
    for(int i=1;i&lt;=n;i++)
    {
        f[i][0][0]=0;
        for(int state=0;state&lt;(1&lt;&lt;m);state++)
        {
            f[i][state][1]=f[i-1][state][0]+fee[i];
            for(int j=1;j&lt;=m;j++)
            {
                if(!(state&amp;(1&lt;&lt;(j-1)))) continue;
                Min(f[i][state][1],f[i][state-(1&lt;&lt;(j-1))][1]+cost[i][j]);
                Min(f[i][state][1],f[i][state-(1&lt;&lt;(j-1))][0]+cost[i][j]+fee[i]);
            }
            Min(f[i][state][0],f[i-1][state][0]);
            Min(f[i][state][0],f[i][state][1]);
        }
    }

    for(int i=1;i&lt;=n;i++) 
        Min(ans,f[i][(1&lt;&lt;m)-1][1]),Min(ans,f[i][(1&lt;&lt;m)-1][0]);

    cout&lt;&lt;ans&lt;&lt;endl;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.12考试总结]]></title>
        <id>https://lcy09.github.io/post/20201112-summary/</id>
        <link href="https://lcy09.github.io/post/20201112-summary/">
        </link>
        <updated>2020-11-15T13:59:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1">1</h3>
<p>给出一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，求：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>p</mi><mi mathvariant="normal">是</mi><mi>A</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">排</mi><mi mathvariant="normal">列</mi></mrow></munder><mfrac><mn>1</mn><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>×</mo><mo>(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><mo>)</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mo>(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>p</mi><mi>n</mi></msub><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum\limits_{p是A的排列} \dfrac{1}{p_1\times(p_1+p_2)\times\dots\times(p_1+p_2+\dots+p_n)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.751884em;vertical-align:-1.430444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord cjk_fallback mtight">是</span><span class="mord mathdefault mtight">A</span><span class="mord cjk_fallback mtight">的</span><span class="mord cjk_fallback mtight">排</span><span class="mord cjk_fallback mtight">列</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>运算均在模<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding="application/x-tex">998244353</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span><span class="mord">2</span><span class="mord">4</span><span class="mord">4</span><span class="mord">3</span><span class="mord">5</span><span class="mord">3</span></span></span></span>意义下。</p>
<p><strong>solution</strong></p>
<p>(题解做法虽说我没看懂)</p>
<p>我们考虑这样一个问题，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个有编号的桶子，编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的桶子有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>个有编号的球，如果每个桶子中随机抽出一个 球，问每个桶子都抽到给定的球的概率，显然它是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>×</mo><mi>A</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mi>A</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\dfrac{1}{A[1]\times A[2]\times \dots\times A[n]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>那么我们换一个种抽法考虑，如果我们每次抽球是在剩下 的所有桶子中抽一个，抽到这个后将这个桶子扔掉，那么正 好抽到每个桶子指定的球的概率还是与之前的式子是相等 的，因为方案总数相等。那么对于这一种方法怎么计算概率 呢？我们先枚举抽到的桶子的顺序，那么对于一个顺序即排 列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，正好抽到这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个球的概率为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>+</mo><mo>…</mo><mi>A</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow></mfrac><mo>×</mo><mfrac><mn>1</mn><mrow><mi>A</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>+</mo><mo>…</mo><mi>A</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mn>1</mn><mrow><mi>A</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\dfrac{1}{A[1]+\dots A[n]}\times \dfrac{1}{A[2]+\dots A[n]}\times\dots\times\dfrac{1}{A[n]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这不就是我们题目中所求的式子吗?所以答案就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>×</mo><mi>A</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mi>A</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\dfrac{1}{A[1]\times A[2]\times\dots\times A[n]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>实际上大家都是手动模拟俩小的然后发现规律……</p>
<p>代码略</p>
<h3 id="2">2</h3>
<p><strong>【题目描述】</strong></p>
<p>在两个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的网格上染色，每个网格中被染色的格子必须是一个四联通块(没有任何格子被染色也可以)，四联通块是指所有染了色的格子可以通过网格的边联通，现在给出哪 些格子在两个网格上都被染色了，保证网格的最外围一层不 会在两个网格中同时被染色，即所有处于第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 列满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">y=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的格子不会被在两个网格中同时被 染色，请求出任意一种染色的方案，如果无解，请输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>.</p>
<p><strong>【输入格式】</strong></p>
<p>第一行两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>.</p>
<p>接下来一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的 01 矩阵，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行 $m $个数字，每个数字之间无空格，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 表示没有同时被染色，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 表示在两 个网格中同时被染色。</p>
<p><strong>【输出格式】</strong></p>
<p>如果有解，则输出两个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的 01 矩阵，分别表示两个矩阵的染色情况，数字之间无空格，两个矩阵之间有一行空 行。<br>
如果无解输出一行一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>.</p>
<p><strong>solution</strong></p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int,int&gt;
#define MP make_pair
using namespace std;
const int MAXN=505;
inline void write(int x)
{
    if(x) putchar('1');
    else putchar('0');
}

int n,m;
char temp[MAXN];
bool g[MAXN][MAXN];

bool Ans[2][MAXN][MAXN];

void print()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
            write(Ans[0][i][j]);
        putchar(10);
    }
    putchar(10);
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
            write(Ans[1][i][j]);
        putchar(10);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s&quot;,temp+1);
        for(int j=1;j&lt;=m;j++)
        {
            if(temp[j]=='1') g[i][j]=1;
        }
    }

    for(int i=1;i&lt;=n;i++)
    {
        Ans[0][i][1]=Ans[1][i][m]=1;
        for(int j=2;j&lt;m;j++)
            Ans[i&amp;1][i][j]=1;
    }
    for(int i=2;i&lt;n;i++)
        for(int j=2;j&lt;m;j++)
        {
            if(!g[i][j]) continue;
            if(!Ans[0][i][j]) Ans[0][i][j]=1;
            if(!Ans[1][i][j]) Ans[1][i][j]=1;
        }
    
    print();
    
    return 0;
}
</code></pre>
<h3 id="3">3</h3>
<p><strong>【题目描述】</strong></p>
<p>给出一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 的行和 $W $列的网格。第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 列的状态是由一个字母的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示，如下：</p>
<p>“.” 此格为空。</p>
<p>“o” 此格包含一个机器人。</p>
<p>“E” 此格包含一个出口，保证出口在整个网格中有且只 有一个。</p>
<p>每次可以选择上，下，左，右之一的方向，将所有剩余的机 器人向这个方向移动一个格子，如果一个机器人被移出了网 格，那么这个机器人会爆炸，并立即消失。如果一个机器人 移动到出口所在的格子，机器人将获救，并消失，最多有多 少机器人获救。</p>
<p><strong>【输入格式】</strong></p>
<p>第一行两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>. 接下来一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的字符矩阵，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个字符，每个字符之间无空格，字符意义如题所示。</p>
<p><strong>【输出格式】</strong></p>
<p>输出一个整数，即最大的获救的机器人的数量。</p>
<p><strong>solution</strong></p>
<p>如果全是机器人动显得有点麻烦，那么不如让出口和整张地图动（想象针扎着一张纸在动）。然后用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r][u][d]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>表示出口向左、右、上、下各动了相应格数的最大能救出数量，转移如图</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clenovo%5CDocuments%5CGridea%5Cpost-images%5CSnipaste_2020-11-12_21-59-58.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo><mo>+</mo><mi mathvariant="normal">紫</mi><mi mathvariant="normal">色</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">人</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi><mo>)</mo><mspace linebreak="newline"></mspace><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo><mo>+</mo><mi mathvariant="normal">绿</mi><mi mathvariant="normal">色</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">人</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f[l][r][u][d+1]=max(f[l][r][u][d+1], f[l][r][u][d]+紫色区域机器人数量) \\
f[l][r+1][u][d]=max(f[l][r+1][u][d], f[l][r][u][d]+绿色区域机器人数量)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">紫</span><span class="mord cjk_fallback">色</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">人</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">绿</span><span class="mord cjk_fallback">色</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">人</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span></span></span></span></span></p>
<p>以此类推</p>
<p>但是转移麻烦得不行详见代码</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=101;

int n,m;
char temp[MAXN];
bool g[MAXN][MAXN];
int bx,by;
int sum[MAXN][MAXN];
int get_zone(int x1,int y1,int x2,int y2)
{
    if(x1&gt;x2||y1&gt;y2) return 0;
    if(!x1||!y1||!x2||!y2) return 0;
    if(x1&gt;n||y1&gt;m||x2&gt;n||y2&gt;m) return 0;
    int res=0;
    res+=(sum[x2][y2]+sum[x1-1][y1-1]);
    res-=(sum[x1-1][y2]+sum[x2][y1-1]);
    return res;
}

int f[2][MAXN][MAXN][MAXN];
void Max(int &amp;a,int b)
{
    if(b&gt;a) a=b;
}
int ans;

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s&quot;,temp+1);
        for(int j=1;j&lt;=m;j++)
        {
            if(temp[j]=='E') bx=i,by=j;
            if(temp[j]=='o') g[i][j]=1;
        }
    }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            sum[i][j]=g[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];//前缀和优化
    
    for(int l=0;l&lt;=m;l++)
        for(int r=0;r&lt;=m;r++)
            for(int u=0;u&lt;=n;u++)
                for(int d=0;d&lt;=n;d++)
                {
                    int tl=l&amp;1;//滚动数组否则空间会炸
                    if(r&lt;by-l-1)//左边没走到爆炸区域
                        Max(f[tl^1][r][u][d],f[tl][r][u][d]+get_zone(max(d+1,bx-u),by-l-1,min(n-u,bx+d),by-l-1));
                    //上下端点判断合法性
                    if(m-l+1&gt;by+r+1)//右边没走到爆炸区
                        Max(f[tl][r+1][u][d],f[tl][r][u][d]+get_zone(max(d+1,bx-u),by+r+1,min(n-u,bx+d),by+r+1));
                    //上下端点判断合法性
                    if(d&lt;bx-u-1)//上边没走到爆炸区
                        Max(f[tl][r][u+1][d],f[tl][r][u][d]+get_zone(bx-u-1,max(r+1,by-l),bx-u-1,min(m-l,by+r)));
                    //左右端点判断合法性
                    if(n-u+1&gt;bx+d+1)//下边没走到爆炸区
                        Max(f[tl][r][u][d+1],f[tl][r][u][d]+get_zone(bx+d+1,max(r+1,by-l),bx+d+1,min(m-l,by+r)));
                    //左右端点判合法
                    Max(ans,f[tl][r][u][d]);//更新答案
                }

    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="4">4</h3>
<p><strong>题目描述</strong></p>
<p>一句话题意：给定一个长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>,给定一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>,问序列中有多少区间的平均数严格大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>.</p>
<p><strong>输入格式</strong></p>
<p>输入共有两行。</p>
<p>第一行是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>⩽</mo><mn>100000</mn><mo separator="true">,</mo><mi>M</mi><mo>⩽</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">N⩽100000,M⩽10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8200000000000001em;vertical-align:-0.13667em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>);</p>
<p>第二行是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个正整数,均不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p>
<p><strong>输出格式</strong></p>
<p>输出只有一个数，为满足条件的区间总数。</p>
<p><strong>solution</strong></p>
<p>发现制约操作的主要是平均数一定的情况下，区间长度不同则区间和不同。容易发现在平均数为0的时候不受此限制，所以把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>转化成0，即序列内所有数都减去<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>,求序列中区间和大于0的区间。</p>
<p>那么就可以进行前缀和优化，然后用权值树状数组维护离散化后的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>值。假设当前点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,我们需要令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">sum_i-sum_{pre}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,即找出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>&lt;</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">sum_{pre}&lt;sum_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">pre</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span>数量，那么在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>数组中直接lower_bound找第一个小于当前值的位置，然后在权值树状数组中查询，并更新答案和树状数组即可。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">//要认真推式子……要细心……
#include&lt;bits/stdc++.h&gt;
#define int long long//不开long long见祖宗
using namespace std;
const int MAXN=100005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,m;
int a[MAXN],sum[MAXN];

int temp[MAXN],len;
void disc()
{
    for(int i=0;i&lt;=n;i++)
        temp[++len]=sum[i];
    sort(temp+1,temp+len+1);
    len=unique(temp+1,temp+len+1)-temp-1;
    for(int i=0;i&lt;=n;i++)
        sum[i]=lower_bound(temp+1,temp+len+1,sum[i])-temp;
}

struct TreeArray
{
    int ta[MAXN];
    int lowbit(int x) {return x&amp;-x;}
    void add(int pos,int adding)
    {
        for(int i=pos;i&lt;=len;i+=lowbit(i)) ta[i]+=adding;
    }
    int query(int pos)
    {
        int res=0;
        for(int i=pos;i;i-=lowbit(i)) res+=ta[i];
        return res;
    }
}TA;

int ans;

signed main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++) 
        a[i]=read(),a[i]-=m,sum[i]=sum[i-1]+a[i];

    disc();
    TA.add(sum[0],1);//提前加入一个0来产生答案
    for(int i=1;i&lt;=n;i++)
    {
        int pos=lower_bound(temp+1,temp+len+1,temp[sum[i]])-temp;
        //找权值树状数组的下标，就是没套temp挂了qaq
        ans+=TA.query(pos-1);
        TA.add(sum[i],1);
    }
    
    cout&lt;&lt;ans&lt;&lt;endl;

    return 0;
}
</code></pre>
<h3 id="5">5</h3>
<p><strong>题目描述</strong></p>
<p>现在有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 张萌猫后卫顺序排成一排，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 只萌猫后卫的攻击力为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，血量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，可以由相邻后卫触发的伤害值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>你的攻击力为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">atk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，每次攻击你可以选择一只存活的萌猫后卫，减少其血量值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">atk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>。若其血量小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则该萌猫后 卫死亡。当某只萌猫后卫死亡时，其左右两侧（若存在）的萌猫后卫会靠拢并成为相邻关系。</p>
<p>在攻击第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 只萌猫后卫时，除了要承受这只萌猫后卫自身的攻击力 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之外，还要承受与其相邻的 2 张萌猫后卫的触发攻击力值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">b_{i−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">b_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>（若存在）。</p>
<p>你的任务是计算在杀死所有萌猫后卫的情况下最少需要承受的伤害值。</p>
<p><strong>输入格式</strong></p>
<p>第一行一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，表示萌猫后卫的数量。</p>
<p>第二行一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">atk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，表示你的攻击力。</p>
<p>以下行，每行3个值：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i,b_i,h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分别表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 只萌猫后卫自身的攻击力值、附加攻击力值、自身血量值。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，表示杀死所有萌猫后卫需要承受的最少伤害值。</p>
<p><strong>solution</strong></p>
<p>就是区间dp，一般这种题区间都很小，就像数位dp一样直接dfs递归做就可以。</p>
<p>一定要记住区间是一个整体，附加伤害值要加上区间左端点左边的和区间右端点右边的。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=405;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void Min(int &amp;x,int y)
{
    if(y&lt;x) x=y;
}

int n,atk;
struct Guard
{
    int atx;
    int dev;
    int hp;
}g[MAXN];

int f[MAXN][MAXN];//打死从l到r的所有的最小花费
bool vis[MAXN][MAXN];
inline int opt(int l,int r)
{//记住区间dp不能像线段树一样区间长度=1了就特判返回值
    if(vis[l][r]) return f[l][r];//有过就返回
    vis[l][r]=1;//标记防止出问题
    for(register int i=l;i&lt;=r;i++)
    {
        int ts=(g[i].hp-1)/atk+1;//上取整
        int res=(g[i].atx+g[l-1].dev+g[r+1].dev)*ts;
        //解决的是当前区间的所有护卫所以得加的是当前区间左右两个的“提高值”
        if(i!=l)//严格区间
            res+=opt(l,i-1);
        if(i!=r)
            res+=opt(i+1,r);
        Min(f[l][r],res); //更新答案
    }
    return f[l][r];
}

signed main()
{
    n=read(),atk=read();
    for(int i=1;i&lt;=n;i++)
        g[i].atx=read(),g[i].dev=read(),g[i].hp=read();

    memset(f,0x3f,sizeof(f));
    printf(&quot;%lld\n&quot;,opt(1,n));

    return 0;
}
</code></pre>
<p>想说的话：今天的失误还是蛮多的，上午想得过于复杂导致做不出来，晚上又写挂第一题，第二题新学区间dp……所以赶紧调整状态迎接接下来的学习。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.11考试总结]]></title>
        <id>https://lcy09.github.io/post/20201111-summary/</id>
        <link href="https://lcy09.github.io/post/20201111-summary/">
        </link>
        <updated>2020-11-12T10:39:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1solution-to-the-equation">1.Solution to the Equation</h3>
<p><strong>【题目描述】</strong></p>
<p>给出一个二元一次方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 是未知数，求它的正整数解的<br>
数量。</p>
<p><strong>【输入格式】</strong></p>
<p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，表示有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 组数据。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 行，每行 3 个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a,b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>.</p>
<p><strong>【输出格式】</strong></p>
<p>输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 行，每行一个数，表示方程解的数量。如果正整数解的数量比<br>
$65535 $还多，输出“ZenMeZheMeDuo”.</p>
<p><strong>solution</strong></p>
<p>首先是一堆特判（因为是正整数解），在代码里会体现，这里不讲。</p>
<p>接下来看怎样求出正整数解数量。首先进行打表观察(这里拿<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>5</mn><mo separator="true">,</mo><mi>a</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ax+by=5,a=3,b=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>举个例子)</p>
<table>
<thead>
<tr>
<th></th>
<th>x</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>解1</td>
<td>-1</td>
<td>4</td>
</tr>
<tr>
<td>解2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>解3</td>
<td>3</td>
<td>-2</td>
</tr>
</tbody>
</table>
<p>发现从一个解到相邻一个解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>增加（或减少）了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mi>a</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{lcm(a,b)}{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>增加（或减少）了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{lcm(a,b)}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.那么设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>a</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mi>a</mi></mfrac><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">sa=|\frac{lcm(a,b)}{a}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord">∣</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>b</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mi>b</mi></mfrac><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">sb=|\frac{lcm(a,b)}{b}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord">∣</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span></span></span></span>,其中一组解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;,y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,可得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>s</mi><mi>a</mi><mo>∗</mo><mi>k</mi><mo>+</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mo>−</mo><mi>s</mi><mi>b</mi><mo>∗</mo><mi>k</mi><mo>+</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x=sa*k+x&#x27;,y=-sb*k+y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">s</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,画出来之后就这个样子：</p>
<figure data-type="image" tabindex="1"><img src="https://lcy09.github.io/post-images/1605177771947.png" alt="" loading="lazy"></figure>
<p>所以我们只需要求出两个零点之间有多少整数点即可。</p>
<p><strong>代码</strong></p>
<pre><code class="language-cpp">//找一组特解然后用同步直线判断出来
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    if(x&gt;65535)
    {
        puts(&quot;ZenMeZheMeDuo&quot;);
        return ;
    }
    short s[20],len=0;
    if(!x) putchar('0');
    if(x&lt;0) putchar('-'),x=-x;
    while(x) s[++len]=x%10,x/=10;
    while(len) putchar('0'|s[len--]);
    putchar(10);
}
inline int gcd(int x,int y)
{
    return y?gcd(y,x%y):x;
}
int T;
int a,b,c;
bool check()//特判们
{
    if((a&lt;=0&amp;&amp;b&lt;=0&amp;&amp;c&gt;0)||(a&gt;=0&amp;&amp;b&gt;=0&amp;&amp;c&lt;0))
    {//无法形成正整数解
        puts(&quot;0&quot;);
        return 1;
    }
    if(c%gcd(a,b))//无解
    {
        puts(&quot;0&quot;);
        return 1;
    }
    if((!a&amp;&amp;b)||(!b&amp;&amp;a))
    {//其中一个数是0就随便瞎取所以是无数组解
        puts(&quot;ZenMeZheMeDuo&quot;);
        return 1;
    }
    if((a&lt;0&amp;&amp;b&gt;0)||(a&gt;0&amp;&amp;b&lt;0)||(!a&amp;&amp;!b&amp;&amp;!c)) 
    {//会形成无数多组解
        puts(&quot;ZenMeZheMeDuo&quot;);
        return 1;
    }
    if(a+b==c)//只会有一组正整数解
    {
        puts(&quot;1&quot;);
        return 1;
    }
    return 0;
}

int x,y;
inline void exgcd(int a,int b)
{
    if(!b)
    {
        x=1,y=0;
        return ;
    }
    exgcd(b,a%b);
    int z=x;
    x=y,y=z-y*(a/b);
}

signed main()
{
    T=read();
    while(T--)
    {
        a=read(),b=read(),c=read();

        if(check()) continue;
        
        exgcd(a,b);
        x*=(c/gcd(a,b)),y*=(c/gcd(a,b));
        int Lcm=a*b/gcd(a,b);
        int sa=abs(Lcm/a),sb=abs(Lcm/b);
        sb=-sb;
        bool dira=(sa&gt;0),dirb=(sb&gt;0);//斜率是正还是负
        double la=(double)(-x/(sa*1.0)),lb=(double)(-y/(sb*1.0));
        //两个零点
        if((la&gt;lb&amp;&amp;!dira&amp;&amp;dirb)||(la&lt;lb&amp;&amp;dira&amp;&amp;!dirb))
        {
            if(la&gt;lb) swap(la,lb);
            int ta=((int)la&gt;la?(int)la:(int)la+1);
            //找出第一个比它大的整数
            int tb=((int)lb&lt;lb?(int)lb:(int)lb-1);
            //找出第一个比它小的
            write(tb-ta+1);
        }
    }

    return 0;
}
</code></pre>
<h3 id="2洛谷p3177-树上染色">2.洛谷P3177 树上染色</h3>
<p><a href="https://www.luogu.com.cn/problem/P3177">P3177</a></p>
<p><strong>solution</strong></p>
<p>显然是dp.</p>
<p>设状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示在以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为根的子树里选<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个黑点的最大收益，转移就像树形背包，不同的是加的不是价值而是当前这条边的贡献。</p>
<p>注意树形背包一定要从上往下做啊啊啊啊！！！</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=2005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(!x) putchar('0');
    if(x&lt;0) putchar('-'),x=-x;
    while(x) s[++len]=x%10,x/=10;
    while(len) putchar('0'|s[len--]);
    putchar(10);
}

int n,m;
int head[MAXN];
struct EDGE
{
    int from,to;
    int val;
    int next;
}edge[MAXN&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to,int val)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].val=val;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}

int siz[MAXN];
int f[MAXN][MAXN];
void dfs(int x,int fath)
{
    siz[x]=1;
    f[x][0]=f[x][1]=0;
    for(int i=head[x];i;i=edge[i].next)
    {
        int y=edge[i].to;
        if(y==fath) continue;
        dfs(y,x);
        siz[x]+=siz[y];
        //这个可以看做集资,当前点的其他子树出j-k个,子树y出k个
        for(int j=min(siz[x],m);j&gt;=0;j--)
            for(int k=0;k&lt;=min(siz[y],j);k++)
            {
                if(f[x][j-k]==-1) continue;
                int delt=edge[i].val*(k*(m-k)+(siz[y]-k)*(n-m-siz[y]+k));
                f[x][j]=max(f[x][j],f[x][j-k]+f[y][k]+delt);
            }
    }
}
signed main()
{
    n=read(),m=read();
    for(int i=2;i&lt;=n;i++)
    {
        int u=read(),v=read(),va=read();
        add_edge(u,v,va),add_edge(v,u,va);
    }
    memset(f,-1,sizeof(f));
    dfs(1,0);
    
    write(f[1][m]);

    return 0;
}
</code></pre>
<h3 id="3和4">3和4</h3>
<p>在有了</p>
<h3 id="5无题">5.无题</h3>
<p><strong>输入格式</strong></p>
<p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">L,R,x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>内有多少个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 满足将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 写成十进制后，从高位到低位不存在两个连续的数位恰好是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>。</p>
<p>例如在数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12345</mn></mrow><annotation encoding="application/x-tex">12345</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span><span class="mord">5</span></span></span></span> 中，存在的上述连续数位有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>12</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">2</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>23</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{23}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">3</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>34</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{34}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord">4</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>45</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{45}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord">5</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>；在数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12312</mn></mrow><annotation encoding="application/x-tex">12312</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 中，存在的上述连续数位有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>12</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">2</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>23</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{23}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">3</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mn>31</mn><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444400000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord">1</span></span></span><span style="top:-3.76444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个数，表示满足题目要求的数的个数。</p>
<p><strong>solution</strong></p>
<p>水数位dp记得判前导0.</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">//虽说是水货但要记得判前导0……
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int le,ri,x,y;
int num[20],len;
int f[20][15][2][2];

int dfs(int pos,int pre,bool lim,bool has)
{
    if(!pos) return has&amp;&amp;(pre!=11);
    if(f[pos][pre][lim][has]!=-1)
        return f[pos][pre][lim][has];
    int Mval=9,res=0;
    if(lim) Mval=num[pos];
    for(int i=0;i&lt;=Mval;i++)
        res+=dfs(pos-1,(!i&amp;&amp;pre==11)?11:i,lim&amp;&amp;(i==Mval),has||(i==y&amp;&amp;pre==x));
    return f[pos][pre][lim][has]=res;
}
int solve(int x)
{
    memset(num,0,sizeof(num));
    memset(f,-1,sizeof(f));
    len=0;
    while(x)
        num[++len]=x%10,x/=10;
    return dfs(len,11,1,0);
}

signed main()
{
    le=read(),ri=read(),x=read(),y=read();
    cout&lt;&lt;(ri-le+1-(solve(ri)-solve(le-1)))&lt;&lt;endl;

    return 0;
}
</code></pre>
<h3 id="6洛谷p3544-bez-minimalist-security">6.洛谷P3544 BEZ-Minimalist Security</h3>
<p><a href="https://www.luogu.com.cn/problem/P3544">P3544</a></p>
<p><strong>solution</strong></p>
<p>这个题可以像债务清单那样每个连通块选一个点设为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,然后通过边权求出所有点的表达式，接着进行有解无解判断之类的。</p>
<p>如果找到一个奇环则需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x\in[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>😭<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>初始是0和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><msub><mi>l</mi><mrow><mi mathvariant="normal">起</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">点</mi></mrow></msub></mrow><annotation encoding="application/x-tex">val_{起始点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">起</span><span class="mord cjk_fallback mtight">始</span><span class="mord cjk_fallback mtight">点</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，通过令该连通块内每个点等于0和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><msub><mi>l</mi><mrow><mi mathvariant="normal">起</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">点</mi></mrow></msub></mrow><annotation encoding="application/x-tex">val_{起始点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">起</span><span class="mord cjk_fallback mtight">始</span><span class="mord cjk_fallback mtight">点</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来更新)</p>
<p>如果是偶环需要常数项相等否则无解。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int,int&gt;
#define MP make_pair
#define int long long
const int MAXN=500005;
const int MAXM=3000005;
using namespace std;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,m;
int per[MAXN],temp[MAXN];

int head[MAXN];
struct EDGE
{
    int from,to;
    int need;
    int next;
}edge[MAXM&lt;&lt;1];
int edge_cnt=1;
void add_edge(int fr,int to,int ned)
{
    edge[++edge_cnt].from=fr;
    edge[edge_cnt].to=to;
    edge[edge_cnt].need=ned;
    edge[edge_cnt].next=head[fr];
    head[fr]=edge_cnt;
}
int Minans,Maxans;

struct Stack
{
    int q[MAXN&lt;&lt;1],len;
    void push(int x) {q[++len]=x;}
    void pop() {len--;}
    int top() {return q[len];}
    int size() {return len;}
    bool empty() {return !len;}
    void clear() {len=0;}
}s;
bool vis[MAXN][2];//0是正系数,1是负系数
int val[MAXN][2];//常数项,注意这个是仅仅根据限制来的
void breakout()
{
    puts(&quot;NIE&quot;);
    exit(0);
}
inline void solve(int st)//对于每个连通块进行操作
{
    queue&lt;pii&gt;q;
    s.clear();
    vis[st][0]=1,s.push(st);
    q.push(MP(st,0));
    while(q.size())
    {
        int x=q.front().first,col=q.front().second;
        q.pop();
        for(int i=head[x];i;i=edge[i].next)
        {
            int y=edge[i].to,z=edge[i].need;
            if(!vis[y][0]&amp;&amp;!vis[y][1])
                s.push(y);//在当前连通块中
            if(vis[y][!col])
            {//特判,如果对面和当前点系数能消就看是不是会出现无解
                if(val[y][col^1]+val[x][col]!=z)
                    breakout();
            }
            else
            {//更新对面点
                vis[y][!col]=1,val[y][!col]=z-val[x][col];
                q.push(MP(y,!col));
            }
        }
    }

    int le=0,ri=per[st],sum=0,suM=0;
    for(int i=1;i&lt;=s.size();i++)
    {
        int pt=s.q[i];//找出连通块中所有点
        if(vis[pt][0])//0=x+b,per[st]=x+b来更新
            le=max(le,-val[pt][0]),ri=min(ri,per[pt]-pt[val][0]);
        if(vis[pt][1])//0=-x+b,per[st]=-x+b来更新
            le=max(le,val[pt][1]-per[pt]),ri=min(ri,val[pt][1]);
        if(vis[pt][0]&amp;&amp;vis[pt][1])//x+b1=-x+b2来更新
        {
            if((val[pt][1]-val[pt][0])&amp;1)
                breakout();//非整数解
            le=max(le,(val[pt][1]-val[pt][0])&gt;&gt;1);
            ri=min(ri,(val[pt][1]-val[pt][0])&gt;&gt;1);
        }
    }
    if(le&gt;ri) breakout();
    for(int i=1;i&lt;=s.size();i++)
    {
        int pt=s.q[i];
        if(vis[pt][0])//其中一个极值（代入式子）
            sum+=per[pt]-le-val[pt][0],suM+=per[pt]-ri-val[pt][0];
        else//另一个极值
            sum+=per[pt]+le-val[pt][1],suM+=per[pt]+ri-val[pt][1];
    }
    if(sum&gt;suM) swap(sum,suM);
    Minans+=sum,Maxans+=suM;//更新答案
}

signed main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++) per[i]=read();
    for(int i=1;i&lt;=m;i++)
    {
        int u=read(),v=read(),nd=read();
        add_edge(u,v,nd),add_edge(v,u,nd);
    }

    for(int i=1;i&lt;=n;i++)
    {
        if(vis[i][0]||vis[i][1]) continue;
        solve(i);
    }

    printf(&quot;%lld %lld\n&quot;,Minans,Maxans);

    return 0;
}
</code></pre>
<h3 id="7在有了">7在有了</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.10考试总结]]></title>
        <id>https://lcy09.github.io/post/20201110-summary/</id>
        <link href="https://lcy09.github.io/post/20201110-summary/">
        </link>
        <updated>2020-11-11T07:34:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1斐波那契">1.斐波那契</h3>
<p><strong>1.1 description</strong></p>
<p>斐波那契数列又称兔子数列，可以通过以下方式产生：一开始只有一只兔子，一个月之后这<br>
只兔子每个月会繁殖出另一只兔子。之后每只兔子出生后都按照以上规则繁殖。我们把每个月的 兔子的数量作为数列中的数就可以得到斐波那契数列。 现在草原上有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 只兔子排成一排，每只兔子有一个繁殖能力 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>小 F 想把这些兔子分组，要求一个组内的兔子必须是连续的一段。而且因为兔子们不太喜欢兔子数列，所以组内任意两只兔 子的繁殖能力的和不能在兔子数列中出现。 现在小 F 想让这些兔子的分组数量尽可能少，但是兔子很多，他算不过来，于是他找到了你， 想让你告诉他最少的分组数量是多少。<br>
<strong>1.2 input</strong><br>
第一行一个整数$ n$，表示兔子的个数。 接下来一行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数，依次表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>
<strong>1.3 output</strong><br>
输出一个数，表示最小的分组数量。</p>
<p><strong>solution</strong></p>
<p>发现可以直接贪心，让当前的段尽可能的长，那么就要判断下一个元素是否合法。因为这个值域内的斐波那契数很少，所以可以用哈希表+斐波那契数列的前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>45</mn></mrow><annotation encoding="application/x-tex">45</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">5</span></span></span></span>项直接判即可。</p>
<p><strong>代码</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=100005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n;
int a[MAXN];
int fib[60],len;

struct HashTable
{
    int head[MAXN],data_cnt=0;
    int mod=100000;
    struct node
    {
        int val;
        int next;
    }data[MAXN&lt;&lt;1];
    int get_key(int x) {return x%mod;}
    bool find(int val)
    {
        for(int i=head[get_key(val)];i;i=data[i].next)
        {
            if(data[i].val==val) return 1;
        }
        return 0;
    }
    void insert(int val)
    {
        int ke=get_key(val);
        data[++data_cnt].val=val;
        data[data_cnt].next=head[ke];
        head[ke]=data_cnt;
    }
    void clear()
    {
        for(int i=1;i&lt;=data_cnt;i++)
        {
            head[get_key(data[i].val)]=0;
            data[i].val=data[i].next=0;
        }
        data_cnt=0;
    }
}HT;
int ans;

signed main()
{
    n=read();
    for(int i=1;i&lt;=n;i++) a[i]=read();

    fib[0]=fib[1]=1;
    for(int i=2;i&lt;=50;i++)
    {
        fib[i]=fib[i-1]+fib[i-2],len=i;
        if(fib[i]&gt;1e10) break;
    }
    for(int i=1;i&lt;=n;i++)
    {
        int bpos=lower_bound(fib+1,fib+len+1,a[i])-fib;
        for(int j=bpos;j&lt;=len;j++)
        {
            if(HT.find(fib[j]-a[i]))
                ans++,HT.clear();
        }
        HT.insert(a[i]);
    }
    ans++;

    printf(&quot;%lld\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="2序列">2.序列</h3>
<p><strong>2.1 description</strong></p>
<p>最近小 X 对序列的研究产生了一定的兴趣。 小 X 把一个区间的中位数看成将这个区间内的数排序之后位于中间的数，如果区间的长度为 偶数的话则是较小的数。</p>
<p>一开始，小 X 想研究一个序列的所有区间中，中位数最大的区间是哪一个。 后来他想了想觉得太简单了，于是决定把这个问题加大一点难度：小 X 现在想知道有多少区 间的中位数位于他给定的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_1, r_1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 之间。</p>
<p>后来他想了想便自己解决了这个问题，于是他再加入了一个限制：区间的长度必须位于$ [l_2, r_2]$<br>
之间。</p>
<p>小 X 发现加了这样一个限制之后，他自己也不会做了。于是他想让你帮他解决这个问题。<br>
<strong>2.2 input</strong><br>
第一行有两个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>，表示序列的长度和询问的次数。 第二行有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数，分别表示原来序列的数。 接下来有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 行，每一行有四个正整数，分别表示每个询问的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>l</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">l_1, r_1, l_2, r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>
<strong>2.3 output</strong><br>
输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>行，每一行表示每个询问对应的答案。</p>
<p><strong>solution</strong></p>
<p>首先解决中位数值域的问题。</p>
<p>发现对于一个序列，其中位数小于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,当且仅当其中小于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的数的数量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和其中大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的数的数量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⩾</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\geqslant b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>.那么考虑对于一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>,应当满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⩾</mo><msub><mi>b</mi><mi>r</mi></msub><mo>−</mo><msub><mi>b</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_r-a_{l-1}\geqslant b_r-b_{l-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8450009999999999em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,移项，得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub><mo>−</mo><msub><mi>b</mi><mi>r</mi></msub><mo>⩾</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>b</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_r-b_r\geqslant a_{l-1}-b_{l-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>询问的次数很少，所以可以看成是单次询问来做。现在考虑如何解决对于区间长度的限制。因为值域现在转化成了一个点，所以上述的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>都是可求的，就可以枚举右端点，查看左端点可以存在的区间，然后用主席书维护每个位置的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>,就可以快速求出每个右端点的答案，最后加和即可。</p>
<p><strong>代码</strong></p>
<pre><code class="language-cpp">/*
首先询问就5个,可以看作是单次询问统计答案

*/
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=100005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(!x) putchar('0');
    if(x&lt;0) putchar('-'),x=-x;
    while(x) s[++len]=x%10,x/=10;
    while(len) putchar('0'|s[len--]);
    putchar(10);
}

int n,m;
int a[MAXN];

//注意这里的主席树是对题解里那个c开的,即小于等于某一个值的数量减去大于的
int cnt_node,root[MAXN];//主席树
struct node
{
    int ls,rs;
    int cnt;
}tree[MAXN&lt;&lt;5];
inline void clearify()//每次的清空
{
    for(int i=1;i&lt;=n;i++) root[i]=0;
    for(int i=1;i&lt;=cnt_node;i++)
        tree[i]={0,0,0};
    cnt_node=0;
}
inline int insert(int num,int l,int r,int val)//插入
{
    int t=++cnt_node;
    tree[t]=tree[num],tree[t].cnt++;
    if(l==r) return t;
    int mid=(l+r)&gt;&gt;1;
    if(val&lt;=mid) tree[t].ls=insert(tree[t].ls,l,mid,val);
    else tree[t].rs=insert(tree[t].rs,mid+1,r,val);
    return t;
}
inline int query(int u,int v,int L,int R,int l,int r)
{//大写的是线段树区间小写的是询问区间
    if(L==l&amp;&amp;R==r) return tree[v].cnt-tree[u].cnt;
    int mid=(L+R)&gt;&gt;1;
    if(r&lt;=mid)
        return query(tree[u].ls,tree[v].ls,L,mid,l,r);
    if(l&gt;mid) 
        return query(tree[u].rs,tree[v].rs,mid+1,R,l,r);
    else 
        return query(tree[u].ls,tree[v].ls,L,mid,l,mid)+query(tree[u].rs,tree[v].rs,mid+1,R,mid+1,r);
}
inline int solve(int va,int sl,int sr)
{//中位数不大于va,区间长度在ll和lr之间
    root[1]=insert(root[1],0,n&lt;&lt;1,n);//初始加入一个为了后面产生答案
    int ct=0,res=0;
    for(int i=1;i&lt;=n;i++)//枚举右端点
    {
        if(a[i]&lt;=va) ct++;//预处理题解里那个c
        else ct--;
        root[i+1]=insert(root[i],0,n&lt;&lt;1,ct+n);//插到下一个位置,为了下面写着方便
        res+=query(root[max(i-sr,0ll)],root[max(i-sl+1,0ll)],0,n&lt;&lt;1,0,ct+n);
        //查询左端点可以在的区间里面的答案
    }
    clearify();
    return res;
}

signed main()
{
    n=read();
    for(int i=1;i&lt;=n;i++) a[i]=read();
    
    m=read();
    while(m--)
    {
        int vl=read(),vr=read(),sl=read(),sr=read();
        write(solve(vr,sl,sr)-solve(vl-1,sl,sr));//直接对于中位数小于等于某个数前缀和相减
    }

    return 0;
}
</code></pre>
<h3 id="3栅栏">3.栅栏</h3>
<p><strong>3.1 description</strong></p>
<p>小 Z 决定要去 AK PION 2018, 不过在这之前，他要先把家里的牛给养大。</p>
<p>小 Z 家里的牛棚是一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">∗</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n ∗ m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mord mathdefault">m</span></span></span></span> 的网格，牛均匀地分布在这些网格中。 一开始小 Z 的牛都很小，习性也都相近，所以牛棚中没有栅栏。</p>
<p>不过随着时间的推移，不同品种的牛的不同习性逐渐暴露出来，这时候小 Z 会建造栅栏来把不同习性的牛给分隔开。不过， 时间久了之后，牛之间也需要交流感情，所以小 Z 有时也可能拆除一些栅栏。</p>
<p>每次小 Z 建造栅栏时，总会先圈出一个矩形内部的牛，然后在这个矩形的边界围一圈栅栏， 也就是说一次建造的栅栏会将某个矩阵的内部与外部给隔开。 每次拆除栅栏时，小 Z 只会拆除之前某个时间建造的栅栏，也就是说一次拆除只会拆除之前 某个时间建造的一个矩阵边界上的所有栅栏。</p>
<p>不过问题也来了：家里的牛棚太大了，栅栏多了之后，小 Z 根本不知道两个位置的牛是否被 栅栏隔开，所以小 Z 想让你帮他解决这个问题。 <strong>当然，为了方便拆除和建造，小 Z 会保证任意时刻栅栏与栅栏之间互不相交。</strong><br>
<strong>3.2 input</strong><br>
第一行两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n, m, q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 表示牛棚的长宽，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 表示接下来发生的事件数。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行有五个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p,x_1,y_1,x_2,y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，表示小 Z 在以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 为左上角，$(x_2, y_2) $为右下角的矩形边界处建造了栅栏。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，表示小 Z 要拆除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 为左上角，$(x_2, y_2) $ 为右下角的矩形外的栅栏（保证<br>
存在）。<br>
如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">p = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，表示小 Z 想询问你位于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1), (x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的牛是否被栅栏隔开。</p>
<p><strong>3.3 output</strong></p>
<p>对于每个询问，如果两个位置没有被隔开，则输出 ”Yes”，否则输出 ”No”。</p>
<p><strong>solution</strong></p>
<p>因为栅栏不相交，所以可以对于每次加栅栏异或一个随机权值，撤掉栅栏的时候再异或回去，判断两个点是不是在同一区域就判断两个点当前的权值即可。</p>
<p>维护需要用到二维树状数组维护差分，然后查询的时候只需要树状数组自动查询前缀和即为当前点的权值。</p>
<hr>
<p>这里介绍一下二维差分。</p>
<p>对于一个二维数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>,定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>位置的差分是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{x,y}-a_{x-1,y}-a_{x,y-1}+a_{x-1,y-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>（有点像容斥是不是）,这样再用树状数组方便地做前缀和就可以快速查出当前点的权值是多少。</p>
<p>注意在进行矩阵加减的时候，假设矩阵的左上角是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,右下角是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,那么应当修改的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个位置:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1),(x_2+1,y_1),(x_1,y_2+1),(x_2+1,y_2+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.修改的正负做题时自己具体判定即可。</p>
<hr>
<p><strong>代码</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define pii pair&lt;int,int&gt;
#define MP make_pair
using namespace std;
const int MAXN=2005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int n,m,q;
struct TreeArray
{
    int a[MAXN][MAXN],lenx,leny;
    void init() {lenx=n,leny=m;}
    int lowbit(int x) {return x&amp;-x;}
    void add(int x,int y,int adding)
    {
        for(int i=x;i&lt;=lenx;i+=lowbit(i))
            for(int j=y;j&lt;=leny;j+=lowbit(j))
                a[i][j]^=adding;
    }
    int query(int x,int y)
    {
        int res=0;
        for(int i=x;i;i-=lowbit(i))
            for(int j=y;j;j-=lowbit(j))
                res^=a[i][j];
        return res;
    }
}TA;
map&lt;pii,int&gt;v;//压缩点之后用pair和map进行存储

signed main()
{
    n=read(),m=read(),q=read();
    TA.init();
    while(q--)
    {
        int opt=read();
        int x1=read(),y1=read(),x2=read(),y2=read();
        if(opt==1)
        {
            int va=rand()*rand();
            v[MP(x1*m+y1,x2*m+y2)]=va;
            TA.add(x1,y1,va),TA.add(x2+1,y2+1,va);
            TA.add(x1,y2+1,va),TA.add(x2+1,y1,va);
        }
        if(opt==2)
        {
            int va=v[MP(x1*m+y1,x2*m+y2)];
            TA.add(x1,y1,va),TA.add(x2+1,y2+1,va);
            TA.add(x1,y2+1,va),TA.add(x2+1,y1,va);
        }
        if(opt==3)
            puts(TA.query(x1,y1)==TA.query(x2,y2)?&quot;Yes&quot;:&quot;No&quot;);
    }
    return 0;
}
</code></pre>
<h3 id="cf551c-gukiz-hates-boxes">CF551C GukiZ hates Boxes</h3>
<p><a href="http://codeforces.com/problemset/problem/551/C">CF551C GukiZ hates Boxes</a></p>
<p><strong>solution</strong></p>
<p>发现可以二分答案，检查的时候用并查集不断找当前最远的更新即可。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=1000005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}
inline void write(int x)
{
    short s[20],len=0;
    if(!x) putchar('0');
    if(x&lt;0) putchar('-'),x=-x;
    while(x) s[++len]=x%10,x/=10;
    while(len) putchar('0'|s[len--]);
    putchar(10);
}

int n,m;
int a[MAXN],temp[MAXN];

int fro[MAXN],fa[MAXN];//初始数组,每次操作数组
inline int find(int x)
{
    if(x==fa[x]) return x;
    return fa[x]=find(fa[x]);
}
inline bool check(int lim)
{
    for(int i=1;i&lt;=n;i++)
        fa[i]=fro[i],temp[i]=a[i];
    if(lim&lt;find(n)) return 0;
    for(register int i=1;i&lt;=m;i++)
    {
        int tmp=lim,now=find(n);
        tmp-=now;
        while(tmp)
        {
            if(tmp&lt;temp[now]) 
            {
                temp[now]-=tmp;
                break;
            }
            tmp-=temp[now],temp[now]=0,fa[now]=find(now-1);//能干掉当前排的工作
            now=find(now);//找到下一排
            if(!now) return 1;
        }
        if(!find(n)) return 1;
    }
    return 0;
}

int ans;

signed main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++) 
    {
        a[i]=read();
        if(a[i]) fro[i]=i;
        else fro[i]=i-1;
    }

    int le=0,ri=1e15;
    while(le&lt;=ri)
    {
        int mid=(le+ri)&gt;&gt;1;
        if(check(mid)) ans=mid,ri=mid-1;
        else le=mid+1;
    }

    write(ans);
    
    return 0;
}
</code></pre>
<h3 id="cf1349b-orac-and-medians">CF1349B Orac and Medians</h3>
<p><a href="http://codeforces.com/problemset/problem/1349/B">CF1349B Orac and Medians</a></p>
<p><strong>solution</strong></p>
<p>发现一个规律：一个数列能成当且仅当这个数列中存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>以及一个长度为3的区间存在两个及以上大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的值。</p>
<p>证明就是枚举各种情况。</p>
<p><strong>code</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=100005;
inline int read()
{
    int weight=0,symbol=1;
    char in=getchar();
    while(!isdigit(in))
    {
        if(in=='-') symbol=-1;
        in=getchar();
    }
    while(isdigit(in))
    {
        weight=weight*10+in-'0';
        in=getchar();
    }
    return symbol*weight;
}

int T;
int n,k;
int a[MAXN];
bool check()
{
    if(n==1) return (a[1]==1);
    for(int i=1;i&lt;=n;i++)
        for(int j=i+1;j&lt;=n&amp;&amp;j-i&lt;=2;j++)
            if(a[i]&amp;&amp;a[j]) return 1;
    return 0;
}

signed main()
{
    T=read();
    while(T--)
    {
        bool flag=0;
        n=read(),k=read();
        for(int i=1;i&lt;=n;i++) 
        {
            a[i]=read();//标记一手方便判断
            if(a[i]&lt;k) a[i]=0;
            if(a[i]==k) a[i]=1,flag=1;
            if(a[i]&gt;k) a[i]=2;
        }
        if(!flag)
        {
            puts(&quot;no&quot;);
            continue;
        }
        puts(check()?&quot;yes&quot;:&quot;no&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://lcy09.github.io/post/about/</id>
        <link href="https://lcy09.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>lcy09的OI博客</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>lcy09,一名sjzez的学生</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>CR(???)</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>QQ:1181033655</p>
]]></content>
    </entry>
</feed>